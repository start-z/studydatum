文章参阅地址：

| 名称 | 地址 | 类型 |
| --- | --- | --- |
| [DesignPattern](https://github.com/youlookwhat/DesignPattern) | [https://github.com/youlookwhat/DesignPattern](https://github.com/youlookwhat/DesignPattern) | gitHub地址 |

headFirst设计模式：抽空一定看看这本书。

## 1.观察者模式

**概念：**定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的**所有的依赖者都会收到通知并自动更新**。

示例：微信公众号以及用户的订阅及其取消订阅及其通知。

### 自定义代码

```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 公众号积累
 */
public interface VxOfficialAccountBase {

    /**
     * 订阅
     *
     * @param user 订阅一个用户
     */
    public void subscribe(VxUser user);

    /**
     * 取消订阅
     *
     * @param user 取消一个订阅用户
     */
    public void unsubscribe(VxUser user);

    /**
     * 通知所有的人并更新
     *
     * @param msg 发布的信息
     */
    public void noticeAllUser(String msg);

}
```

```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户基类
 */
public interface VxUserBase {
    void update(String msg);
}
```

```java
package custom;

import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/11
 * description: vx公众号基类 一对多的关系
 */
public class VxOfficialAccount implements VxOfficialAccountBase {

    protected List<VxUser> users = new ArrayList<>();

    private String msg;

    /**
     * 订阅
     *
     * @param user 订阅的用户
     */
    @Override
    public void subscribe(VxUser user) {
        users.add(user);
    }

    /**
     * 取消订阅
     *
     * @param user 取消订阅的用户
     */
    @Override
    public void unsubscribe(VxUser user) {
        users.remove(user);
    }

    /**
     * 通知所有的订阅者并更新
     *
     * @param msg 发布的信息
     */
    @Override
    public void noticeAllUser(String msg) {
        users.forEach(user -> user.update(msg));
    }

    /**
     * 当微信号状态发生改变的时候通知所有人更新
     *
     * @param msg 相关消息
     */
    void setMsg(String msg) {
        this.msg = msg;
        noticeAllUser(msg);
    }
}
```

```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description:  公众号用户基类
 */
public class VxUser implements VxUserBase {
    /**
     * 初始化时订阅相关公众号
     * @param vxOfficialAccount 相关公众号类
     */
    public VxUser(VxOfficialAccount vxOfficialAccount) {
        vxOfficialAccount.subscribe(this);
    }

    @Override
    public void update(String msg) {
        System.out.println("修改相关数据," + msg);
    }
}
```

```
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户自定义的公众号服务测试类
 */
public class userWatch {
    public static void main(String[] args) {
        VxOfficialAccount account = new VxOfficialAccount();
        VxUser vxUser1 = new VxUser(account);
        VxUser vxUser2 = new VxUser(account);
        account.setMsg("我通知了所有人");
    }
}
```

### 使用源码的观察者模式

```
package jdk;

import java.util.Observable;
import java.util.Observer;

/**
* @author zhou
* @since 2023/10/11
* description: 用户实现类
*/
public class JdkUser implements Observer {

public JdkUser(Observable observable) {
observable.addObserver(this);
}

@Override
public void update(Observable o, Object arg) {
JdkVxAcc jdkVxAcc = (JdkVxAcc) o;
System.out.println("由于公众号状态更新,我接受到了相关的信息，所以我被打印出来了");
}

public static void main(String[] args) {
JdkVxAcc acc = new JdkVxAcc();
JdkUser jdkUser = new JdkUser(acc);
acc.setMsg("123");
}
}

```

```
package jdk;

import java.util.Observable;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 实现源码主题基类
 */
public class JdkVxAcc extends Observable {
    private String msg;


    public String getMsg() {
        return msg;
    }


    /**
     * 主题更新
     *
     * @param msg
     */
    public void setMsg(String msg) {
        this.msg = msg;
        setChanged();
        notifyObservers();
    }
}

```

## 2工厂模式

工厂定义：当软件开发过程中使用接口时，代码中往往需要实例化大量的具体类，而这些实现大多是由一些条件决定的。对于如何实例化对象这个问题，往往**考虑用一个单独的类来处理创造实例**的过程。

### 静态工厂模式

```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 静态工厂
 */
public class staticFactory {

    private static void createBean(String msg) {
        System.out.println("我是静态工厂创建bean");
    }
}

```

### 简单工厂模式

```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 简单工厂模式
 */
public class EasyFactory {

    /**
     * 根据传入的类型返回参数
     * @param type 类型
     */
    public String createBean(Integer type) {
        String value = "";
        switch (type) {
            case 1:
                value = "1";
                break;
            case 2:
                value = "2";
                break;
            default:
                break;
        }
        return value;
    }
}

```

### 工厂方法模式

**定义：**定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。 其实就是简单工厂多一个抽象父类或者接口。

### 抽象工厂模式

**定义：**提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。 其实就是工厂方法中多创建方法然后返回相关依赖bean给子类使用。

## 3单例模式

**定义：**保证整个应用中有且只有一个实例。
使用场景：A和B类都需要使用到一个通用类的属性，当A进行NEW对象的时候对通用类属性赋值，当B去修改的时候去读取A修改的变量,于是会发现读取的是默认值，这个时候是因为A和B都NEW了通用类对象，有2种做法。
1：讲属性设置为static，这样会导致长期停留在生命周期中，不安全。 2：使用单例模式去构建通用类对象，确保A和B使用的都是同一个通用类。

### 懒汉式

```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 饿汉类单例模式
 */
public class HungerSingleon {
    public static HungerSingleon hungerSingleon = new HungerSingleon();

    public HungerSingleon() {
    }

    public static HungerSingleon creatHungerSigleon() {
        return hungerSingleon;
    }
}

```

```
Singleton instance = Singleton.getInstance();
```

优点：在类初始化的时候就实例化了类。 确定：正是因为使用了static初始化实例，导致全局存在对象，浪费内存（可以忽略不计）。 另外这种模式线程是不安全的，
**推荐**：可用。

### 饿汉式

```
public class Singleton{
 
	private static Singleton instance = null;
	
	static {
		instance = new Singleton();
	}
 
	private Singleton() {};
 
	public static Singleton getInstance() {
		return instance;
	}
}
```

```
Singleton instance = Singleton.getInstance();
```

其实你会发现他和懒汉式大致看起来没有什么不同。唯一的区别可能就是static的使用，一个是静态代码块声明，一个是静态变量声明。优缺点自然也和懒汉式一致。
**推荐**：可用。

### 懒汉式双重校验

我们见识过简单的懒汉式后，其实会诱发线程安全的问题，下面提供一个简单的懒汉式代码。（特别注意这与上述的示例懒汉式代码不同，上述实例懒汉式代码是用static修饰，不需要考虑线程安全的情况，因为你在是用static后就注定这个对象是全局存在的）

```
    public class OrdinarySingleon {
        public OrdinarySingleon ordinarySingleon = null;

        public OrdinarySingleon() {
        }

        /**
         * 普通懒汉式-线程不安全
         *
         * @return 普通懒汉式
         */
        public OrdinarySingleon createOrdinarySingleon() {
            if (ordinarySingleon == null) {
                ordinarySingleon = new OrdinarySingleon();
            }
            return ordinarySingleon;
        }
    }
```

设计到线程安全的话我们一定会进行加锁。

```
    /**
     * 普通懒汉式-线程安全-使用synchronized修饰方法 效率低下
     * @return 普通懒汉式
     */
    public synchronized SecHungerSingleon createSecSecHungerSingleon() {
        if (secHungerSingleon == null) {
            secHungerSingleon = new SecHungerSingleon();
        }
        return secHungerSingleon;
    }
```

但是上述这种加锁的方式效率低下所以我们采用同步代码块的方式去处理。

```
    /**
     * 普通懒汉式-线程安全-使用同步代码块
     * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
     * @return 普通懒汉式
     */
    public SecHungerSingleon createSycSecHungerSingleon() {
        if (secHungerSingleon == null) {
            synchronized (SecHungerSingleon.class) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
        return secHungerSingleon;
    }
```

但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例。 于是我们只需要在外层在判断一遍即可。这就是所谓的懒汉式线程安全双重校验。

```
/**
 * 普通懒汉式-线程安全-使用同步代码块
 * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
 * @return 普通懒汉式
 */
public SecHungerSingleon createSycSecTwoHungerSingleon() {
    if (secHungerSingleon == null) {
        synchronized (SecHungerSingleon.class) {
            if (secHungerSingleon == null) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
    }
    return secHungerSingleon;
}
```

### 内部类

```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 内部类
 */
public class InnerClassSingleon {
    public InnerClassSingleon() {
    }

    private static class InnerClassSingleonHander {
        private static InnerClassSingleon innerClassSingleon = new InnerClassSingleon();
    }

    public InnerClassSingleon getInstance() {
        return InnerClassSingleonHander.innerClassSingleon;
    }
}

```

比起普通懒汉式的好处就是实现了静态类的懒加载。

### 枚举类

```
/**
 * 单例模式-枚举
 * @author BJB314
 */
public class EnumSingleon {
    private EnumSingleon() {}
    

    public enum SingletonEnum {
        // 实例对象
        instance;
        /**
         * 实例化bean
         */
        private EnumSingleon enumSingleon;

        SingletonEnum() {
            enumSingleon = new EnumSingleon();
        }

        public EnumSingleon getInstance() {
            return instance.enumSingleon;
        }
    }
}

```

## 4策略模式

**定义：**定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。
**理解：**遵循设计的原则，找出应用中可能需要变化的部分，把它们独立出来，不要和那些不需要变化的代码混在一起。
**示例：**一个用户有专属的名字和特殊的吃饭方式、跑步动作等等属性。

```
    public class User {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void run() {
        }

        public void eat() {
        }

        public void write() {
        }

        public void change() {
        }
    }
```

现在我们创建A和B的用户,只需要分别继承创建即可。但是呢一旦用户多了起来以后你就会发现许多重复的代码（重复的技能等等等）所以我们要改变，将技能封装起来并扩展。这样一旦后来的用户有使用到之前用户的动作时直接复用即可。

```
   public class newUser {
        private String name;
        private write write;
        private change change;
        private eat eat;
        private run run;

        public StrateGicMode.write getWrite() {
            return write;
        }

        public void setWrite(StrateGicMode.write write) {
            this.write = write;
        }

        public StrateGicMode.change getChange() {
            return change;
        }

        public void setChange(StrateGicMode.change change) {
            this.change = change;
        }

        public StrateGicMode.eat getEat() {
            return eat;
        }

        public void setEat(StrateGicMode.eat eat) {
            this.eat = eat;
        }

        public StrateGicMode.run getRun() {
            return run;
        }

        public void setRun(StrateGicMode.run run) {
            this.run = run;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
```

可以看到，我们现在只需要扩展用户基类然后单独设置名称即可。重复的动作都被我们封装了起来，后续直接对用户进行赋值即可。

## 5适配器模式

**定义：**把两个不兼容的东西转换为能够关联。
**示例：**小米手机没有耳机孔，但是有充电口，于是我们会使用到转换器（适配器）去让充电口能通过转换器插上耳机。

```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 适配器模式
 */
public class Adapter {
    /**
     * 手机基类
     */
    public class Moblie {
        private String type = "TypecC";
    }

    /**
     * 耳机基类
     */
    public class Headset {
        private String type = "CircularHole";
    }

    /**
     * 转换器
     */
    public class TypecCoverCircularHole {
        public void typecCoverCircularHole(Headset headset, Moblie moblie) {
            moblie.type = headset.type;
        }
    }
}

```

## 6命令模式

**定义：**将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
**示例：** 我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。

```
import java.util.Arrays;

/**
 * @author zhou
 * @since 2023/10/12
 * description: 命令模式-我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。
 */
public class Command {
    public class ControlCenter {
        public Robot[] robots;

        /**
         * 添加指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void addRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = robot;
        }
        /**
         * 删除指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void removeRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = null;
        }

        /**
         * 一键执行
         */
        public void execute() {
            Arrays.stream(robots).forEach(robot -> robot.execute());
        }
    }

    /**
     * 机器人基类
     */
    public interface Robot {
        void execute();
    }
}

```

## 7装饰模式

**定义：**若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。
**使用场景：**在原来的代码上进行扩展，而不是修改本来的类。 示例：我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。

```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 装饰品模式-我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
 * 每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。
 */
public  class Decortion {

    public static void main(String[] args) {
        new Decortion().execute();
    }

    public  void execute() {
        // 装蝴蝶结和小河马的爱马仕
        ADecoration aDecoration = new ADecoration(new BDecoration(new Aclothing()));
        System.out.println(aDecoration.name);
    }

    public class Clothing {
        public String name;
    }

    public class Decoration extends Clothing {
        public Clothing clothing;
    }

    public  class Aclothing extends Clothing {

        public Aclothing() {
            super.name = "爱马仕";
        }
    }

    public class Bclothing extends Clothing {

        public Bclothing() {
            super.name = "香奈儿";
        }
    }

    public class ADecoration extends Decoration {

        public ADecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-蝴蝶结";
        }
    }

    public class BDecoration extends Decoration {

        public BDecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-小河马";
        }
    }
}
```

## 8外观模式

**定义：**提供统一的接口，用来访问子系统的各种接口然后封装。
**实例：**我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。

```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 外观模式-我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。
 */
public class Appearance {
    private Televistion televistion;
    private Sound sound;

    public void open() {
        televistion.open();
        sound.open();
    }

    public interface Electron {
        void open();

        void close();
    }

    public class Televistion implements Electron {
        @Override
        public void open() {
            System.out.println("电视机打开");
        }

        @Override
        public void close() {
            System.out.println("电视机关闭");
        }
    }

    public class Sound implements Electron {
        @Override
        public void open() {
            System.out.println("音响打开");
        }

        @Override
        public void close() {
            System.out.println("音响关闭");
        }
    }
}

```

## 9模板方法模式

**定义：**定义了一个算法**的骨架**，而将一些步骤**延迟到**[**
子类**](https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020)中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。（子类集成父类的抽象方法，具体的实现交给子类完成）
**示例：**A和B一起去网吧打游戏，记录他们上网的行为。

```
/**
 * @author zhou
 * @since 2023/10/16
 * description: 设计模式-模板方法
 */
public abstract class TemplateMethod {

    public abstract void palyer();

    public void record() {
        System.out.println("我开启电脑");
        System.out.println("我开始上网了");
        this.palyer();
        System.out.println("我结束上网");
        System.out.println("我关闭电脑");
    }

    public class A extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩lol");
        }
    }

    public class B extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩CF");
        }
    }
}
```

## 10状态模式

**定义：**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

