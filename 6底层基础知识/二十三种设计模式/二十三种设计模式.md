文章参阅地址：

| 名称 | 地址 | 类型 |
| --- | --- | --- |
| [https://github.com/youlookwhat/DesignPattern](https://github.com/youlookwhat/DesignPattern) | [https://github.com/youlookwhat/DesignPattern](https://github.com/youlookwhat/DesignPattern) | gitHub地址 |
| [建造者模式 &#124; 菜鸟教程](https://www.runoob.com/design-pattern/builder-pattern.html) | [https://www.runoob.com/design-pattern/builder-pattern.html](https://www.runoob.com/design-pattern/builder-pattern.html) | 菜鸟教程 |

headFirst设计模式：抽空一定看看这本书。
## 1.观察者模式

**概念：**定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的**所有的依赖者都会收到通知并自动更新**。

示例：微信公众号以及用户的订阅及其取消订阅及其通知。

### 自定义代码
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 公众号积累
 */
public interface VxOfficialAccountBase {

    /**
     * 订阅
     *
     * @param user 订阅一个用户
     */
    public void subscribe(VxUser user);

    /**
     * 取消订阅
     *
     * @param user 取消一个订阅用户
     */
    public void unsubscribe(VxUser user);

    /**
     * 通知所有的人并更新
     *
     * @param msg 发布的信息
     */
    public void noticeAllUser(String msg);

}
```
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户基类
 */
public interface VxUserBase {
    void update(String msg);
}
```
```java
package custom;

import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/11
 * description: vx公众号基类 一对多的关系
 */
public class VxOfficialAccount implements VxOfficialAccountBase {

    protected List<VxUser> users = new ArrayList<>();

    private String msg;

    /**
     * 订阅
     *
     * @param user 订阅的用户
     */
    @Override
    public void subscribe(VxUser user) {
        users.add(user);
    }

    /**
     * 取消订阅
     *
     * @param user 取消订阅的用户
     */
    @Override
    public void unsubscribe(VxUser user) {
        users.remove(user);
    }

    /**
     * 通知所有的订阅者并更新
     *
     * @param msg 发布的信息
     */
    @Override
    public void noticeAllUser(String msg) {
        users.forEach(user -> user.update(msg));
    }

    /**
     * 当微信号状态发生改变的时候通知所有人更新
     *
     * @param msg 相关消息
     */
    void setMsg(String msg) {
        this.msg = msg;
        noticeAllUser(msg);
    }
}
```
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description:  公众号用户基类
 */
public class VxUser implements VxUserBase {
    /**
     * 初始化时订阅相关公众号
     * @param vxOfficialAccount 相关公众号类
     */
    public VxUser(VxOfficialAccount vxOfficialAccount) {
     vxOfficialAccount.subscribe(this);
    }

 @Override
 public void update(String msg) {
  System.out.println("修改相关数据," + msg);
 }
}
```
```
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户自定义的公众号服务测试类
 */
public class userWatch {
    public static void main(String[] args) {
        VxOfficialAccount account = new VxOfficialAccount();
        VxUser vxUser1 = new VxUser(account);
        VxUser vxUser2 = new VxUser(account);
        account.setMsg("我通知了所有人");
    }
}
```
### 使用源码的观察者模式
```
package jdk;

import java.util.Observable;
import java.util.Observer;

/**
* @author zhou
* @since 2023/10/11
* description: 用户实现类
*/
public class JdkUser implements Observer {

public JdkUser(Observable observable) {
observable.addObserver(this);
}

@Override
public void update(Observable o, Object arg) {
JdkVxAcc jdkVxAcc = (JdkVxAcc) o;
System.out.println("由于公众号状态更新,我接受到了相关的信息，所以我被打印出来了");
}

public static void main(String[] args) {
JdkVxAcc acc = new JdkVxAcc();
JdkUser jdkUser = new JdkUser(acc);
acc.setMsg("123");
}
}

```
```
package jdk;

import java.util.Observable;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 实现源码主题基类
 */
public class JdkVxAcc extends Observable {
    private String msg;


    public String getMsg() {
        return msg;
    }


    /**
     * 主题更新
     *
     * @param msg
     */
    public void setMsg(String msg) {
        this.msg = msg;
        setChanged();
        notifyObservers();
    }
}

```

## 2工厂模式
工厂定义：当软件开发过程中使用接口时，代码中往往需要实例化大量的具体类，而这些实现大多是由一些条件决定的。对于如何实例化对象这个问题，往往**考虑用一个单独的类来处理创造实例**的过程。
### 静态工厂模式
```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 静态工厂
 */
public class staticFactory {

    private static void createBean(String msg) {
        System.out.println("我是静态工厂创建bean");
    }
}

```
### 简单工厂模式
```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 简单工厂模式
 */
public class EasyFactory {

    /**
     * 根据传入的类型返回参数
     * @param type 类型
     */
    public String createBean(Integer type) {
        String value = "";
        switch (type) {
            case 1:
                value = "1";
                break;
            case 2:
                value = "2";
                break;
            default:
                break;
        }
        return value;
    }
}

```
### 工厂方法模式

**定义：**定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。 其实就是简单工厂多一个抽象父类或者接口。
### 抽象工厂模式

**定义：**提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。 其实就是工厂方法中多创建方法然后返回相关依赖bean给子类使用。
## 3单例模式

**定义：**保证整个应用中有且只有一个实例。
使用场景：A和B类都需要使用到一个通用类的属性，当A进行NEW对象的时候对通用类属性赋值，当B去修改的时候去读取A修改的变量,于是会发现读取的是默认值，这个时候是因为A和B都NEW了通用类对象，有2种做法。
1：讲属性设置为static，这样会导致长期停留在生命周期中，不安全。 2：使用单例模式去构建通用类对象，确保A和B使用的都是同一个通用类。
### 懒汉式
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 饿汉类单例模式
 */
public class HungerSingleon {
    public static HungerSingleon hungerSingleon = new HungerSingleon();

    public HungerSingleon() {
    }

    public static HungerSingleon creatHungerSigleon() {
        return hungerSingleon;
    }
}

```
```
Singleton instance = Singleton.getInstance();
```

优点：在类初始化的时候就实例化了类。 确定：正是因为使用了static初始化实例，导致全局存在对象，浪费内存（可以忽略不计）。 另外这种模式线程是不安全的，
**推荐**：可用。
### 饿汉式
```
public class Singleton{
 
	private static Singleton instance = null;
	
	static {
		instance = new Singleton();
	}
 
	private Singleton() {};
 
	public static Singleton getInstance() {
		return instance;
	}
}
```
```
Singleton instance = Singleton.getInstance();
```
其实你会发现他和懒汉式大致看起来没有什么不同。唯一的区别可能就是static的使用，一个是静态代码块声明，一个是静态变量声明。优缺点自然也和懒汉式一致。
**推荐**：可用。
### 懒汉式双重校验
我们见识过简单的懒汉式后，其实会诱发线程安全的问题，下面提供一个简单的懒汉式代码。（特别注意这与上述的示例懒汉式代码不同，上述实例懒汉式代码是用static修饰，不需要考虑线程安全的情况，因为你在是用static后就注定这个对象是全局存在的）
```
    public class OrdinarySingleon {
        public OrdinarySingleon ordinarySingleon = null;

        public OrdinarySingleon() {
        }

        /**
         * 普通懒汉式-线程不安全
         *
         * @return 普通懒汉式
         */
        public OrdinarySingleon createOrdinarySingleon() {
            if (ordinarySingleon == null) {
                ordinarySingleon = new OrdinarySingleon();
            }
            return ordinarySingleon;
        }
    }
```
设计到线程安全的话我们一定会进行加锁。
```
    /**
     * 普通懒汉式-线程安全-使用synchronized修饰方法 效率低下
     * @return 普通懒汉式
     */
    public synchronized SecHungerSingleon createSecSecHungerSingleon() {
        if (secHungerSingleon == null) {
            secHungerSingleon = new SecHungerSingleon();
        }
        return secHungerSingleon;
    }
```
但是上述这种加锁的方式效率低下所以我们采用同步代码块的方式去处理。
```
    /**
     * 普通懒汉式-线程安全-使用同步代码块
     * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
     * @return 普通懒汉式
     */
    public SecHungerSingleon createSycSecHungerSingleon() {
        if (secHungerSingleon == null) {
            synchronized (SecHungerSingleon.class) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
        return secHungerSingleon;
    }
```

但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例。 于是我们只需要在外层在判断一遍即可。这就是所谓的懒汉式线程安全双重校验。
```
/**
 * 普通懒汉式-线程安全-使用同步代码块
 * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
 * @return 普通懒汉式
 */
public SecHungerSingleon createSycSecTwoHungerSingleon() {
    if (secHungerSingleon == null) {
        synchronized (SecHungerSingleon.class) {
            if (secHungerSingleon == null) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
    }
    return secHungerSingleon;
}
```
### 内部类
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 内部类
 */
public class InnerClassSingleon {
    public InnerClassSingleon() {
    }

    private static class InnerClassSingleonHander {
        private static InnerClassSingleon innerClassSingleon = new InnerClassSingleon();
    }

    public InnerClassSingleon getInstance() {
        return InnerClassSingleonHander.innerClassSingleon;
    }
}

```
比起普通懒汉式的好处就是实现了静态类的懒加载。
### 枚举类
```
/**
 * 单例模式-枚举
 * @author BJB314
 */
public class EnumSingleon {
    private EnumSingleon() {}
    

    public enum SingletonEnum {
        // 实例对象
        instance;
        /**
         * 实例化bean
         */
        private EnumSingleon enumSingleon;

        SingletonEnum() {
            enumSingleon = new EnumSingleon();
        }

        public EnumSingleon getInstance() {
            return instance.enumSingleon;
        }
    }
}

```
## 4策略模式
**定义：**定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。
**理解：**遵循设计的原则，找出应用中可能需要变化的部分，把它们独立出来，不要和那些不需要变化的代码混在一起。
**示例：**一个用户有专属的名字和特殊的吃饭方式、跑步动作等等属性。
```
    public class User {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void run() {
        }

        public void eat() {
        }

        public void write() {
        }

        public void change() {
        }
    }
```
现在我们创建A和B的用户,只需要分别继承创建即可。但是呢一旦用户多了起来以后你就会发现许多重复的代码（重复的技能等等等）所以我们要改变，将技能封装起来并扩展。这样一旦后来的用户有使用到之前用户的动作时直接复用即可。
```
   public class newUser {
        private String name;
        private write write;
        private change change;
        private eat eat;
        private run run;

        public StrateGicMode.write getWrite() {
            return write;
        }

        public void setWrite(StrateGicMode.write write) {
            this.write = write;
        }

        public StrateGicMode.change getChange() {
            return change;
        }

        public void setChange(StrateGicMode.change change) {
            this.change = change;
        }

        public StrateGicMode.eat getEat() {
            return eat;
        }

        public void setEat(StrateGicMode.eat eat) {
            this.eat = eat;
        }

        public StrateGicMode.run getRun() {
            return run;
        }

        public void setRun(StrateGicMode.run run) {
            this.run = run;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
```
可以看到，我们现在只需要扩展用户基类然后单独设置名称即可。重复的动作都被我们封装了起来，后续直接对用户进行赋值即可。
## 5适配器模式
**定义：**把两个不兼容的东西转换为能够关联。
**示例：**小米手机没有耳机孔，但是有充电口，于是我们会使用到转换器（适配器）去让充电口能通过转换器插上耳机。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 适配器模式
 */
public class Adapter {
    /**
     * 手机基类
     */
    public class Moblie {
        private String type = "TypecC";
    }

    /**
     * 耳机基类
     */
    public class Headset {
        private String type = "CircularHole";
    }

    /**
     * 转换器
     */
    public class TypecCoverCircularHole {
        public void typecCoverCircularHole(Headset headset, Moblie moblie) {
            moblie.type = headset.type;
        }
    }
}

```
## 6命令模式
**定义：**将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
**示例：** 我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。
```
import java.util.Arrays;

/**
 * @author zhou
 * @since 2023/10/12
 * description: 命令模式-我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。
 */
public class Command {
    public class ControlCenter {
        public Robot[] robots;

        /**
         * 添加指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void addRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = robot;
        }
        /**
         * 删除指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void removeRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = null;
        }

        /**
         * 一键执行
         */
        public void execute() {
            Arrays.stream(robots).forEach(robot -> robot.execute());
        }
    }

    /**
     * 机器人基类
     */
    public interface Robot {
        void execute();
    }
}

```
## 7装饰模式

**定义：**若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。
**使用场景：**在原来的代码上进行扩展，而不是修改本来的类。 示例：我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 装饰品模式-我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
 * 每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。
 */
public  class Decortion {

    public static void main(String[] args) {
        new Decortion().execute();
    }

    public  void execute() {
        // 装蝴蝶结和小河马的爱马仕
        ADecoration aDecoration = new ADecoration(new BDecoration(new Aclothing()));
        System.out.println(aDecoration.name);
    }

    public class Clothing {
        public String name;
    }

    public class Decoration extends Clothing {
        public Clothing clothing;
    }

    public  class Aclothing extends Clothing {

        public Aclothing() {
            super.name = "爱马仕";
        }
    }

    public class Bclothing extends Clothing {

        public Bclothing() {
            super.name = "香奈儿";
        }
    }

    public class ADecoration extends Decoration {

        public ADecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-蝴蝶结";
        }
    }

    public class BDecoration extends Decoration {

        public BDecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-小河马";
        }
    }
}
```
## 8外观模式
**定义：**提供统一的接口，用来访问子系统的各种接口然后封装。
**实例：**我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 外观模式-我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。
 */
public class Appearance {
    private Televistion televistion;
    private Sound sound;

    public void open() {
        televistion.open();
        sound.open();
    }

    public interface Electron {
        void open();

        void close();
    }

    public class Televistion implements Electron {
        @Override
        public void open() {
            System.out.println("电视机打开");
        }

        @Override
        public void close() {
            System.out.println("电视机关闭");
        }
    }

    public class Sound implements Electron {
        @Override
        public void open() {
            System.out.println("音响打开");
        }

        @Override
        public void close() {
            System.out.println("音响关闭");
        }
    }
}

```
## 9模板方法模式

**定义：**定义了一个算法**的骨架**，而将一些步骤**延迟到**[**
子类**](https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020)中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。（子类集成父类的抽象方法，具体的实现交给子类完成）
**示例：**A和B一起去网吧打游戏，记录他们上网的行为。
```
/**
 * @author zhou
 * @since 2023/10/16
 * description: 设计模式-模板方法
 */
public abstract class TemplateMethod {

    public abstract void palyer();

    public void record() {
        System.out.println("我开启电脑");
        System.out.println("我开始上网了");
        this.palyer();
        System.out.println("我结束上网");
        System.out.println("我关闭电脑");
    }

    public class A extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩lol");
        }
    }

    public class B extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩CF");
        }
    }
}
```
## 10状态模式

**定义：**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 示例： 自动售卖机，有4种状态已投币、未投币、商品售完、商品售出。有四种动作投币、退币、转动手柄、出货。
```
/**
 * @author zhou
 * @since 2023/10/16
 * description: 设计模式-状态模式
 * 自动售卖机，有4种状态已投币、未投币、商品售完、商品售出。有四种动作投币、退币、转动手柄、出货。(由于需求可能会经常变动 所以采用状态模式进行设计)
 */
public class StateMode {

    /**
     * 定义动作基类-new
     */
    public interface BaseAction {
        void coined();

        void coinReturn();
    }

    /**
     * 售卖机新代码。-new
     */
    public class VendingMachineNew {
        // 已投币
        private final BaseAction coined = new Coined(this);
        // 未投币
        private final int unCoinedStatus = 1;
        // 售出
        private final int soedStatus = 2;
        // 售完
        private final int beSoldOutStatus = 3;
        private BaseAction currrentAction = coined;

        /**
         * 投币
         */
        public void coined() {
            currrentAction.coined();
        }

        /**
         * 退币
         */
        public void coinReturn() {
            currrentAction.coinReturn();
        }

    }

    /**
     * 投币状态专用管理-new - 后续状态代码不在编写 知其意即可。
     */
    public class Coined implements BaseAction {
        private VendingMachineNew vendingMachine;

        Coined(VendingMachineNew vendingMachine) {
            this.vendingMachine = vendingMachine;
        }

        @Override
        public void coined() {
            System.out.println("当前售卖机已经投过币了");

        }

        @Override
        public void coinReturn() {
            System.out.println("退币成功");
            // 这里应该是投币状态的实现类  懒得写了
            vendingMachine.currrentAction = null;
        }
    }

    /**
     * 这样设计以后以后增加动作或者状态的时候需要修改原有代码的switch分支特别麻烦。-old
     */
    public class VendingMachineOld {
        // 已投币
        private final int coinedStatus = 0;
        // 未投币
        private final int unCoinedStatus = 1;
        // 售出
        private final int soedStatus = 2;
        // 售完
        private final int beSoldOutStatus = 3;
        private int currrentStatus = unCoinedStatus;

        /**
         * 投币
         */
        public void coined() {
            switch (currrentStatus) {
                case coinedStatus:
                    System.out.println("你已经投过币了");
                    break;
                case unCoinedStatus:
                    System.out.println("你已投币成功");
                    this.currrentStatus = coinedStatus;
                    break;
                case soedStatus:
                    System.out.println("本商品已经售出");
                    break;
                case beSoldOutStatus:
                    System.out.println("本商品已经售完");
                    break;
                default:
                    break;
            }
        }

        /**
         * 退币
         */
        public void coinReturn() {
            switch (currrentStatus) {
                case coinedStatus:
                    System.out.println("退币成功");
                    this.currrentStatus = unCoinedStatus;
                    break;
                case unCoinedStatus:
                    System.out.println("当前售货机没有投币");
                    this.currrentStatus = coinedStatus;
                    break;
                case soedStatus:
                case beSoldOutStatus:
                    System.out.println("本商品已经售完-正在退币中");
                    this.currrentStatus = unCoinedStatus;
                    break;
                default:
                    break;
            }
        }

    }
}

```

## 11建造者模式

**定义:**建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder
类是独立于其他对象的。（**区分变与不变的对象 对需要变动的对象进行灵活扩展设计**）
**示例：**一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold
drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
```
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/19
 * description: 设计模式-构造器模式
 * 需求： 一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
 */
public class Builder {

    /**
     * 使用构建者模式
     */
    public static class DesignBuilder {
        public void tester() {
            MealBuilder mealBuilder = new MealBuilder();

            Meal vegMeal = mealBuilder.prepareVegMeal();
            System.out.println("Veg Meal");
            vegMeal.showItems();
            System.out.println("Total Cost: " + vegMeal.getCost());

            Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
            System.out.println("\n\nNon-Veg Meal");
            nonVegMeal.showItems();
            System.out.println("Total Cost: " + nonVegMeal.getCost());
        }

        /**
         * 商品基类
         */
        public interface Item {
            String name();

            Pack pack();

            float price();
        }

        /**
         * 包装者基类
         */
        public interface Pack {
            String pack();
        }

        public class Wrapper implements Pack {

            @Override
            public String pack() {
                return "Wrapper";
            }
        }

        public class Bottle implements Pack {
            @Override
            public String pack() {
                return "Bottle";
            }
        }

        public abstract class Burger implements Item {

            @Override
            public Pack pack() {
                return new Wrapper();
            }

            @Override
            public abstract float price();
        }

        public abstract class ColdDrink implements Item {

            @Override
            public Pack pack() {
                return new Bottle();
            }

            @Override
            public abstract float price();
        }

        public class VegBurger extends Burger {

            @Override
            public float price() {
                return 25.0f;
            }

            @Override
            public String name() {
                return "Veg Burger";
            }
        }

        public class ChickenBurger extends Burger {

            @Override
            public float price() {
                return 50.5f;
            }

            @Override
            public String name() {
                return "Chicken Burger";
            }
        }

        public class Coke extends ColdDrink {

            @Override
            public float price() {
                return 30.0f;
            }

            @Override
            public String name() {
                return "Coke";
            }
        }

        public class Pepsi extends ColdDrink {

            @Override
            public float price() {
                return 35.0f;
            }

            @Override
            public String name() {
                return "Pepsi";
            }
        }

        public class Meal {
            private List<Item> items = new ArrayList<Item>();

            public void addItem(Item item) {
                items.add(item);
            }

            public float getCost() {
                float cost = 0.0f;
                for (Item item : items) {
                    cost += item.price();
                }
                return cost;
            }

            public void showItems() {
                for (Item item : items) {
                    System.out.print("Item : " + item.name());
                    System.out.print(", Packing : " + item.pack().pack());
                    System.out.println(", Price : " + item.price());
                }
            }
        }

        public class MealBuilder {

            public Meal prepareVegMeal() {
                Meal meal = new Meal();
                meal.addItem(new VegBurger());
                meal.addItem(new Coke());
                return meal;
            }

            public Meal prepareNonVegMeal() {
                Meal meal = new Meal();
                meal.addItem(new ChickenBurger());
                meal.addItem(new Pepsi());
                return meal;
            }
        }
    }


    /**
     * 不使用设计模式的代码编写  后续有些问题 不再修改
     */
    public class requireMentImp {
        public Burger burger = new Burger();
        private Drink drink = new Drink();
        private Pack pack = new Pack();

        public void packageKFC() {
            this.burger = new VegBurger();
            this.drink = new Coffice();
            this.pack = new Pack();
        }

        /**
         * 素食汉堡
         */
        public class VegBurger extends Burger {
        }

        /**
         * 鸡肉汉堡
         */
        public class ChickenBurger extends Burger {
        }

        /**
         * 汉堡
         */
        public class Burger extends BaseCommoodity {
        }

        /**
         * 咖啡
         */
        public class Coffice extends Drink {
        }

        /**
         * 可口可乐
         */
        public class Coke extends Drink {
        }

        /**
         * 饮品
         */
        public class Drink extends BaseCommoodity {
        }

        /**
         * 塑料袋
         */
        public class PlasticBag extends Pack {
        }

        /**
         * 纸盒
         */
        public class Carton extends Pack {
        }

        /**
         * 包装盒
         */
        public class Pack extends BaseCommoodity {
        }

        /**
         * 商品基类
         */
        public class BaseCommoodity {
            private String name;
            private String price;

            private void setName() {
            }

            ;

            private void setprice() {
            }

            ;

        }
    }
}

```
## 12原型模式

copy的菜鸟教程，写的比较清晰，我就不画蛇添足了。 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。 这种模式是**
实现了一个原型接口，该接口用于创建当前对象的克隆**。当**直接创建对象的代价比较大**
时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
**主要解决：**在运行期建立和删除原型。
**何时使用：**
1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。
4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。
**关键代码：** 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone()
方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。
**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。
**优点：** 1、性能提高。 2、逃避构造函数的约束（说的好听，其实就是clone一份）。
**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 **Cloneable（原型接口）**
接口。
**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone
的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。
**注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。
```
import java.util.Hashtable;

/**
 * @author zhou
 * @since 2023/10/19
 * description:  设计模式-原型工厂-本身属于创建性工厂，做法是接口实现对对象的拷贝,可节省内存和频繁构建对象。
 */
public class PrototypePlant {
    /**
     * 克隆基类
     */
    public abstract class Shape implements Cloneable {
        private String id;
        protected String type;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        abstract void draw();

        @Override
        public Object clone() {
            Object clone = null;
            try {
                clone = super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return clone;
        }
    }

    /**
     * 实现基类
     */
    public class Rectangle extends Shape {
        public Rectangle() {
            this.type = "Rectangle";
        }

        @Override
        public void draw() {
            System.out.println("Inside Rectangle::draw() method.");
        }
    }

    public class Square extends Shape {

        public Square() {
            type = "Square";
        }

        @Override
        public void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }

    public class Circle extends Shape {

        public Circle() {
            type = "Circle";
        }

        @Override
        public void draw() {
            System.out.println("Inside Circle::draw() method.");
        }
    }

    /**
     * 构建缓存类
     */
    public class ShapeCache {

        private Hashtable<String, Shape> shapeMap
                = new Hashtable<String, Shape>();

        public Shape getShape(String shapeId) {
            Shape cachedShape = shapeMap.get(shapeId);
            return (Shape) cachedShape.clone();
        }

        // 对每种形状都运行数据库查询，并创建该形状
        // shapeMap.put(shapeKey, shape);
        // 例如，我们要添加三种形状
        public void loadCache() {
            Circle circle = new Circle();
            circle.setId("1");
            shapeMap.put(circle.getId(), circle);

            Square square = new Square();
            square.setId("2");
            shapeMap.put(square.getId(), square);

            Rectangle rectangle = new Rectangle();
            rectangle.setId("3");
            shapeMap.put(rectangle.getId(), rectangle);
        }
    }

    /**
     * 测试类
     */
    public class PrototypePatternDemo {
        public void test() {
            ShapeCache shapeCache = new ShapeCache();
            shapeCache.loadCache();

            Shape clonedShape = (Shape) shapeCache.getShape("1");
            System.out.println("Shape : " + clonedShape.getType());

            Shape clonedShape2 = (Shape) shapeCache.getShape("2");
            System.out.println("Shape : " + clonedShape2.getType());

            Shape clonedShape3 = (Shape) shapeCache.getShape("3");
            System.out.println("Shape : " + clonedShape3.getType());
        }
    }
}

```
## 13享元模式

享元模式（Flyweight Pattern）主要用于**减少创建对象的数量**
，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。（类似于缓存技术，提高对象的复用性，比如常见的数据库缓存池）
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 _Circle_ 对象。
**意图：**运用共享技术有效地支持大量细粒度的对象。
**主要解决：**在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。
5、系统不依赖于这些对象身份，这些对象是不可分辨的。
**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
**关键代码：**用 HashMap 存储这些对象。
**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的连接池。
**优点：**大大**减少对象的创建**，降低系统的内存，使效率提高。
**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。
**使用场景：** 1、系统有大量相似对象。 2、需要缓冲池的场景。
**注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。
```
import java.util.HashMap;

/**
 * @author zhou
 * @since 2023/10/19
 * description: 设计模式-享元模式
 * 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。
 * ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一
 * 个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，
 * 如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。
 */
public class EnyuanMode {

    public class EnyuanFactory() {
        private HashMap<Integer, Shape> cache = new HashMap<int, Shape>();

        public Shape getShape(int id) {
            if (cache.containsKey(id)) {
                return cache.get(id);
            } else {
                Cirle cirle = new Cirle();
                cache.put(id, cirle);
                return cirle;
            }
        }
    }

    public interface Shape {
        int id();

        String name();
    }

    public class Cirle implements Shape {

        @Override
        public int id() {
            return 1;
        }

        @Override
        public String name() {
            return "big";
        }
    }
}
```

## 14代理模式

**意图：**为其他对象提供一种代理以**控制对这个对象的访问**。
**主要解决：**
在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
**何时使用：**想在访问一个类时做一些控制。
**如何解决：**增加中间层。
**关键代码：**实现与被代理类组合。
**应用实例：**
1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。
3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。
**优点：**
1、职责清晰。 2、高扩展性。 3、智能化。
**缺点：**
1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。
7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。
**注意事项：**
1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

```
/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式-代理模式
 */
public class ProxyPattern {

    public interface image {
        void display();
    }

    public class RealImage implements image {

        @Override
        public void display() {
            System.out.println("我显示了");
        }
    }

    public class ProxyImage implements image {
        /**
         * 实现代理
         */
        @Override
        public void display() {
            RealImage image = new RealImage();
            image.display();
        }
    }


}
```

## 15桥接模式

桥接（Bridge）是用于把**抽象化与实现化解耦，使得二者可以独立变化**。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。
桥接模式的目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。 我们通过下面的实例来演示桥接模式（Bridge
Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。
**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。
**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。
**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。
**关键代码：**抽象类依赖实现类。
**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。
2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。
**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。
**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。
2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
**注意事项：**对于两个独立变化的维度，使用桥接模式再适合不过了。 以下是桥接模式的几个关键角色：

- 抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
- 扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
- 实现（Implementor）：定义实现接口，提供基本操作的接口。
- 具体实现（Concrete Implementor）：实现实现接口的具体类。

```
/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式- 桥接模式
 */
public class BridgingMode {
    public abstract class Shape {
        protected DrawAPI drawApi;

        protected Shape(DrawAPI drawApi) {
            this.drawApi = drawApi;
        }

        abstract void draw();

    }


    public interface DrawAPI {
        public void drawCircle(int radius, int x, int y);
    }

    public class Circle extends Shape {
        private int x, y, radius;

        public Circle(int x, int y, int radius, DrawAPI drawAPI) {
            super(drawAPI);
            this.x = x;
            this.y = y;
            this.radius = radius;
        }

        @Override
        void draw() {
            drawApi.drawCircle(x, y, radius);
        }
    }

    public class RedCircle implements DrawAPI {

        @Override
        public void drawCircle(int radius, int x, int y) {
            System.out.println("我是红色的圆");
        }

        ;
    }

    public class BlackCircle implements DrawAPI {
        @Override
        public void drawCircle(int radius, int x, int y) {
            System.out.println("我是黑色的圆");
        }
    }
}
```

上述这个例子表明先设计抽象类图形，然后在扩展对应的抽象实现类圆，交给我们的桥接接口去实现具体的实现类（红圆、黑圆）简单的来说其实就是实体化类用一个接口去衔接具体的抽象化类 ，使得双方修改的同时并不会影响到对方。

## 16组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。
**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。
**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。
**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container
是树枝。
**优点：** 1、高层模块调用简单。 2、节点自由增加。
**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。
**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。
**注意事项：**定义时为具体类。 说白了类似于老师这个类里面有自己学生的集合。

```
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式-组合模式
 */
public class Combination {

    public class Student {
        private String name;
        private String age;
    }

    public class Teacher {
        private String name;
        private String age;
        private List<Student> studentList;
    }
}
```

## 17迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。
**意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
**主要解决：**不同的方式来遍历整个整合对象。
**何时使用：**遍历一个聚合对象。
**如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。
**关键代码：**定义接口：hasNext, next。
**应用实例：**JAVA 中的 iterator。
**优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
**缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
**使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。
**注意事项：**迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
