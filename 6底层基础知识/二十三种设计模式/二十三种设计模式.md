文章参阅地址：

| 名称 | 地址 | 类型 |
| --- | --- | --- |
| [https://github.com/youlookwhat/DesignPattern](https://github.com/youlookwhat/DesignPattern) | [https://github.com/youlookwhat/DesignPattern](https://github.com/youlookwhat/DesignPattern) | gitHub地址 |
| [建造者模式 &#124; 菜鸟教程](https://www.runoob.com/design-pattern/builder-pattern.html) | [https://www.runoob.com/design-pattern/builder-pattern.html](https://www.runoob.com/design-pattern/builder-pattern.html) | 菜鸟教程 |

headFirst设计模式：抽空一定看看这本书。

## 1.观察者模式

**概念：**定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的**所有的依赖者都会收到通知并自动更新**。

示例：微信公众号以及用户的订阅及其取消订阅及其通知。

### 自定义代码
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 公众号积累
 */
public interface VxOfficialAccountBase {

    /**
     * 订阅
     *
     * @param user 订阅一个用户
     */
    public void subscribe(VxUser user);

    /**
     * 取消订阅
     *
     * @param user 取消一个订阅用户
     */
    public void unsubscribe(VxUser user);

    /**
     * 通知所有的人并更新
     *
     * @param msg 发布的信息
     */
    public void noticeAllUser(String msg);

}
```
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户基类
 */
public interface VxUserBase {
    void update(String msg);
}
```
```java
package custom;

import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/11
 * description: vx公众号基类 一对多的关系
 */
public class VxOfficialAccount implements VxOfficialAccountBase {

    protected List<VxUser> users = new ArrayList<>();

    private String msg;

    /**
     * 订阅
     *
     * @param user 订阅的用户
     */
    @Override
    public void subscribe(VxUser user) {
        users.add(user);
    }

    /**
     * 取消订阅
     *
     * @param user 取消订阅的用户
     */
    @Override
    public void unsubscribe(VxUser user) {
        users.remove(user);
    }

    /**
     * 通知所有的订阅者并更新
     *
     * @param msg 发布的信息
     */
    @Override
    public void noticeAllUser(String msg) {
        users.forEach(user -> user.update(msg));
    }

    /**
     * 当微信号状态发生改变的时候通知所有人更新
     *
     * @param msg 相关消息
     */
    void setMsg(String msg) {
        this.msg = msg;
        noticeAllUser(msg);
    }
}
```
```java
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description:  公众号用户基类
 */
public class VxUser implements VxUserBase {
    /**
     * 初始化时订阅相关公众号
     * @param vxOfficialAccount 相关公众号类
     */
    public VxUser(VxOfficialAccount vxOfficialAccount){vxOfficialAccount.subscribe(this);}

    @Override
    public void update(String msg) {
        System.out.println("修改相关数据,"+msg);
    }
}
```

```
package custom;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 用户自定义的公众号服务测试类
 */
public class userWatch {
    public static void main(String[] args) {
        VxOfficialAccount account = new VxOfficialAccount();
        VxUser vxUser1 = new VxUser(account);
        VxUser vxUser2 = new VxUser(account);
        account.setMsg("我通知了所有人");
    }
}
```
### 使用源码的观察者模式
```
package jdk;

import java.util.Observable;
import java.util.Observer;

/**
* @author zhou
* @since 2023/10/11
* description: 用户实现类
*/
public class JdkUser implements Observer {

public JdkUser(Observable observable) {
observable.addObserver(this);
}

@Override
public void update(Observable o, Object arg) {
JdkVxAcc jdkVxAcc = (JdkVxAcc) o;
System.out.println("由于公众号状态更新,我接受到了相关的信息，所以我被打印出来了");
}

public static void main(String[] args) {
JdkVxAcc acc = new JdkVxAcc();
JdkUser jdkUser = new JdkUser(acc);
acc.setMsg("123");
}
}

```
```
package jdk;

import java.util.Observable;

/**
 * @author zhou
 * @since 2023/10/11
 * description: 实现源码主题基类
 */
public class JdkVxAcc extends Observable {
    private String msg;


    public String getMsg() {
        return msg;
    }


    /**
     * 主题更新
     *
     * @param msg
     */
    public void setMsg(String msg) {
        this.msg = msg;
        setChanged();
        notifyObservers();
    }
}

```

## 2工厂模式
工厂定义：当软件开发过程中使用接口时，代码中往往需要实例化大量的具体类，而这些实现大多是由一些条件决定的。对于如何实例化对象这个问题，往往**考虑用一个单独的类来处理创造实例**的过程。
### 静态工厂模式
```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 静态工厂
 */
public class staticFactory {

    private static void createBean(String msg) {
        System.out.println("我是静态工厂创建bean");
    }
}

```
### 简单工厂模式
```
/**
 * @author zhou
 * @since 2023/10/11
 * description: 简单工厂模式
 */
public class EasyFactory {

    /**
     * 根据传入的类型返回参数
     * @param type 类型
     */
    public String createBean(Integer type) {
        String value = "";
        switch (type) {
            case 1:
                value = "1";
                break;
            case 2:
                value = "2";
                break;
            default:
                break;
        }
        return value;
    }
}

```
### 工厂方法模式

**定义：**定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。 其实就是简单工厂多一个抽象父类或者接口。
### 抽象工厂模式

**定义：**提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。 其实就是工厂方法中多创建方法然后返回相关依赖bean给子类使用。
## 3单例模式

**定义：**保证整个应用中有且只有一个实例。
使用场景：A和B类都需要使用到一个通用类的属性，当A进行NEW对象的时候对通用类属性赋值，当B去修改的时候去读取A修改的变量,于是会发现读取的是默认值，这个时候是因为A和B都NEW了通用类对象，有2种做法。
1：讲属性设置为static，这样会导致长期停留在生命周期中，不安全。 2：使用单例模式去构建通用类对象，确保A和B使用的都是同一个通用类。
### 懒汉式
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 饿汉类单例模式
 */
public class HungerSingleon {
    public static HungerSingleon hungerSingleon = new HungerSingleon();

    public HungerSingleon() {
    }

    public static HungerSingleon creatHungerSigleon() {
        return hungerSingleon;
    }
}

```
```
Singleton instance = Singleton.getInstance();
```

优点：在类初始化的时候就实例化了类。 确定：正是因为使用了static初始化实例，导致全局存在对象，浪费内存（可以忽略不计）。 另外这种模式线程是不安全的，
**推荐**：可用。
### 饿汉式
```
public class Singleton{
 
	private static Singleton instance = null;
	
	static {
		instance = new Singleton();
	}
 
	private Singleton() {};
 
	public static Singleton getInstance() {
		return instance;
	}
}
```
```
Singleton instance = Singleton.getInstance();
```
其实你会发现他和懒汉式大致看起来没有什么不同。唯一的区别可能就是static的使用，一个是静态代码块声明，一个是静态变量声明。优缺点自然也和懒汉式一致。
**推荐**：可用。
### 懒汉式双重校验
我们见识过简单的懒汉式后，其实会诱发线程安全的问题，下面提供一个简单的懒汉式代码。（特别注意这与上述的示例懒汉式代码不同，上述实例懒汉式代码是用static修饰，不需要考虑线程安全的情况，因为你在是用static后就注定这个对象是全局存在的）
```
    public class OrdinarySingleon {
        public OrdinarySingleon ordinarySingleon = null;

        public OrdinarySingleon() {
        }

        /**
         * 普通懒汉式-线程不安全
         *
         * @return 普通懒汉式
         */
        public OrdinarySingleon createOrdinarySingleon() {
            if (ordinarySingleon == null) {
                ordinarySingleon = new OrdinarySingleon();
            }
            return ordinarySingleon;
        }
    }
```
设计到线程安全的话我们一定会进行加锁。
```
    /**
     * 普通懒汉式-线程安全-使用synchronized修饰方法 效率低下
     * @return 普通懒汉式
     */
    public synchronized SecHungerSingleon createSecSecHungerSingleon() {
        if (secHungerSingleon == null) {
            secHungerSingleon = new SecHungerSingleon();
        }
        return secHungerSingleon;
    }
```
但是上述这种加锁的方式效率低下所以我们采用同步代码块的方式去处理。
```
    /**
     * 普通懒汉式-线程安全-使用同步代码块
     * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
     * @return 普通懒汉式
     */
    public SecHungerSingleon createSycSecHungerSingleon() {
        if (secHungerSingleon == null) {
            synchronized (SecHungerSingleon.class) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
        return secHungerSingleon;
    }
```

但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例。 于是我们只需要在外层在判断一遍即可。这就是所谓的懒汉式线程安全双重校验。
```
/**
 * 普通懒汉式-线程安全-使用同步代码块
 * 但是这种方式还是不安全-当A和B都执行这段代码时，由于A实例判断没有实例bean就往下走同步代码块,而b这个时候也进来判断 就导致A和B都创建了实例
 * @return 普通懒汉式
 */
public SecHungerSingleon createSycSecTwoHungerSingleon() {
    if (secHungerSingleon == null) {
        synchronized (SecHungerSingleon.class) {
            if (secHungerSingleon == null) {
                secHungerSingleon = new SecHungerSingleon();
            }
        }
    }
    return secHungerSingleon;
}
```
### 内部类
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 内部类
 */
public class InnerClassSingleon {
    public InnerClassSingleon() {
    }

    private static class InnerClassSingleonHander {
        private static InnerClassSingleon innerClassSingleon = new InnerClassSingleon();
    }

    public InnerClassSingleon getInstance() {
        return InnerClassSingleonHander.innerClassSingleon;
    }
}

```
比起普通懒汉式的好处就是实现了静态类的懒加载。
### 枚举类
```
/**
 * 单例模式-枚举
 * @author BJB314
 */
public class EnumSingleon {
    private EnumSingleon() {}
    

    public enum SingletonEnum {
        // 实例对象
        instance;
        /**
         * 实例化bean
         */
        private EnumSingleon enumSingleon;

        SingletonEnum() {
            enumSingleon = new EnumSingleon();
        }

        public EnumSingleon getInstance() {
            return instance.enumSingleon;
        }
    }
}

```
## 4策略模式
**定义：**定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。
**理解：**遵循设计的原则，找出应用中可能需要变化的部分，把它们独立出来，不要和那些不需要变化的代码混在一起。
**示例：**一个用户有专属的名字和特殊的吃饭方式、跑步动作等等属性。
```
    public class User {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void run() {
        }

        public void eat() {
        }

        public void write() {
        }

        public void change() {
        }
    }
```
现在我们创建A和B的用户,只需要分别继承创建即可。但是呢一旦用户多了起来以后你就会发现许多重复的代码（重复的技能等等等）所以我们要改变，将技能封装起来并扩展。这样一旦后来的用户有使用到之前用户的动作时直接复用即可。
```
   public class newUser {
        private String name;
        private write write;
        private change change;
        private eat eat;
        private run run;

        public StrateGicMode.write getWrite() {
            return write;
        }

        public void setWrite(StrateGicMode.write write) {
            this.write = write;
        }

        public StrateGicMode.change getChange() {
            return change;
        }

        public void setChange(StrateGicMode.change change) {
            this.change = change;
        }

        public StrateGicMode.eat getEat() {
            return eat;
        }

        public void setEat(StrateGicMode.eat eat) {
            this.eat = eat;
        }

        public StrateGicMode.run getRun() {
            return run;
        }

        public void setRun(StrateGicMode.run run) {
            this.run = run;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
```
可以看到，我们现在只需要扩展用户基类然后单独设置名称即可。重复的动作都被我们封装了起来，后续直接对用户进行赋值即可。
## 5适配器模式
**定义：**把两个不兼容的东西转换为能够关联。
**示例：**小米手机没有耳机孔，但是有充电口，于是我们会使用到转换器（适配器）去让充电口能通过转换器插上耳机。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 适配器模式
 */
public class Adapter {
    /**
     * 手机基类
     */
    public class Moblie {
        private String type = "TypecC";
    }

    /**
     * 耳机基类
     */
    public class Headset {
        private String type = "CircularHole";
    }

    /**
     * 转换器
     */
    public class TypecCoverCircularHole {
        public void typecCoverCircularHole(Headset headset, Moblie moblie) {
            moblie.type = headset.type;
        }
    }
}

```
## 6命令模式
**定义：**将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
**示例：** 我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。
```
import java.util.Arrays;

/**
 * @author zhou
 * @since 2023/10/12
 * description: 命令模式-我有多个机器人，每个机器人的职责和业务都不相同，现在我需要对这些机器人发送不同的指令，并希望有个发送命令的控制中枢方便控制。
 */
public class Command {
    public class ControlCenter {
        public Robot[] robots;

        /**
         * 添加指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void addRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = robot;
        }
        /**
         * 删除指定按键机器人
         * @param robot 机器人
         * @param keyIndex 按键
         */
        public void removeRobot(Robot robot, Integer keyIndex) {
            robots[keyIndex] = null;
        }

        /**
         * 一键执行
         */
        public void execute() {
            Arrays.stream(robots).forEach(robot -> robot.execute());
        }
    }

    /**
     * 机器人基类
     */
    public interface Robot {
        void execute();
    }
}

```
## 7装饰模式

**定义：**若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。
**使用场景：**在原来的代码上进行扩展，而不是修改本来的类。 示例：我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 装饰品模式-我现在有一些装饰品(分为衣服和小礼物)，每件衣服都有不同的名称，现在我需要去给他们加上指定集合中的元素装饰品，
 * 每件衣服最多只能装饰3个。另外装饰后还会在衣服名称后面加上-装饰品的名称。
 */
public  class Decortion {

    public static void main(String[] args) {
        new Decortion().execute();
    }

    public  void execute() {
        // 装蝴蝶结和小河马的爱马仕
        ADecoration aDecoration = new ADecoration(new BDecoration(new Aclothing()));
        System.out.println(aDecoration.name);
    }

    public class Clothing {
        public String name;
    }

    public class Decoration extends Clothing {
        public Clothing clothing;
    }

    public  class Aclothing extends Clothing {

        public Aclothing() {
            super.name = "爱马仕";
        }
    }

    public class Bclothing extends Clothing {

        public Bclothing() {
            super.name = "香奈儿";
        }
    }

    public class ADecoration extends Decoration {

        public ADecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-蝴蝶结";
        }
    }

    public class BDecoration extends Decoration {

        public BDecoration(Clothing clothing) {
            this.clothing = clothing;
            this.name = clothing.name + "-小河马";
        }
    }
}
```
## 8外观模式
**定义：**提供统一的接口，用来访问子系统的各种接口然后封装。
**实例：**我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。
```
/**
 * @author zhou
 * @since 2023/10/12
 * description: 外观模式-我买了一台电视机，我想要使用他还需要打开音响、使用遥控板、操作电视机等等，如果我们频繁的创建相关的实体类在调用的话是比较麻烦的，我们可以写一个汇总类，然后在这个类中调用相关的操作。
 */
public class Appearance {
    private Televistion televistion;
    private Sound sound;

    public void open() {
        televistion.open();
        sound.open();
    }

    public interface Electron {
        void open();

        void close();
    }

    public class Televistion implements Electron {
        @Override
        public void open() {
            System.out.println("电视机打开");
        }

        @Override
        public void close() {
            System.out.println("电视机关闭");
        }
    }

    public class Sound implements Electron {
        @Override
        public void open() {
            System.out.println("音响打开");
        }

        @Override
        public void close() {
            System.out.println("音响关闭");
        }
    }
}

```
## 9模板方法模式

**定义：**定义了一个算法**的骨架**，而将一些步骤**延迟到**[**
子类**](https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020)中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。（子类集成父类的抽象方法，具体的实现交给子类完成）
**示例：**A和B一起去网吧打游戏，记录他们上网的行为。
```
/**
 * @author zhou
 * @since 2023/10/16
 * description: 设计模式-模板方法
 */
public abstract class TemplateMethod {

    public abstract void palyer();

    public void record() {
        System.out.println("我开启电脑");
        System.out.println("我开始上网了");
        this.palyer();
        System.out.println("我结束上网");
        System.out.println("我关闭电脑");
    }

    public class A extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩lol");
        }
    }

    public class B extends TemplateMethod {

        @Override
        public void palyer() {
            System.out.println("我玩CF");
        }
    }
}
```
## 10状态模式

**定义：**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 示例： 自动售卖机，有4种状态已投币、未投币、商品售完、商品售出。有四种动作投币、退币、转动手柄、出货。
```
/**
 * @author zhou
 * @since 2023/10/16
 * description: 设计模式-状态模式
 * 自动售卖机，有4种状态已投币、未投币、商品售完、商品售出。有四种动作投币、退币、转动手柄、出货。(由于需求可能会经常变动 所以采用状态模式进行设计)
 */
public class StateMode {

    /**
     * 定义动作基类-new
     */
    public interface BaseAction {
        void coined();

        void coinReturn();
    }

    /**
     * 售卖机新代码。-new
     */
    public class VendingMachineNew {
        // 已投币
        private final BaseAction coined = new Coined(this);
        // 未投币
        private final int unCoinedStatus = 1;
        // 售出
        private final int soedStatus = 2;
        // 售完
        private final int beSoldOutStatus = 3;
        private BaseAction currrentAction = coined;

        /**
         * 投币
         */
        public void coined() {
            currrentAction.coined();
        }

        /**
         * 退币
         */
        public void coinReturn() {
            currrentAction.coinReturn();
        }

    }

    /**
     * 投币状态专用管理-new - 后续状态代码不在编写 知其意即可。
     */
    public class Coined implements BaseAction {
        private VendingMachineNew vendingMachine;

        Coined(VendingMachineNew vendingMachine) {
            this.vendingMachine = vendingMachine;
        }

        @Override
        public void coined() {
            System.out.println("当前售卖机已经投过币了");

        }

        @Override
        public void coinReturn() {
            System.out.println("退币成功");
            // 这里应该是投币状态的实现类  懒得写了
            vendingMachine.currrentAction = null;
        }
    }

    /**
     * 这样设计以后以后增加动作或者状态的时候需要修改原有代码的switch分支特别麻烦。-old
     */
    public class VendingMachineOld {
        // 已投币
        private final int coinedStatus = 0;
        // 未投币
        private final int unCoinedStatus = 1;
        // 售出
        private final int soedStatus = 2;
        // 售完
        private final int beSoldOutStatus = 3;
        private int currrentStatus = unCoinedStatus;

        /**
         * 投币
         */
        public void coined() {
            switch (currrentStatus) {
                case coinedStatus:
                    System.out.println("你已经投过币了");
                    break;
                case unCoinedStatus:
                    System.out.println("你已投币成功");
                    this.currrentStatus = coinedStatus;
                    break;
                case soedStatus:
                    System.out.println("本商品已经售出");
                    break;
                case beSoldOutStatus:
                    System.out.println("本商品已经售完");
                    break;
                default:
                    break;
            }
        }

        /**
         * 退币
         */
        public void coinReturn() {
            switch (currrentStatus) {
                case coinedStatus:
                    System.out.println("退币成功");
                    this.currrentStatus = unCoinedStatus;
                    break;
                case unCoinedStatus:
                    System.out.println("当前售货机没有投币");
                    this.currrentStatus = coinedStatus;
                    break;
                case soedStatus:
                case beSoldOutStatus:
                    System.out.println("本商品已经售完-正在退币中");
                    this.currrentStatus = unCoinedStatus;
                    break;
                default:
                    break;
            }
        }

    }
}

```

## 11建造者模式

**定义:**建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder
类是独立于其他对象的。（**区分变与不变的对象 对需要变动的对象进行灵活扩展设计**）
**示例：**一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold
drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
```
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/19
 * description: 设计模式-构造器模式
 * 需求： 一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
 */
public class Builder {

    /**
     * 使用构建者模式
     */
    public static class DesignBuilder {
        public void tester() {
            MealBuilder mealBuilder = new MealBuilder();

            Meal vegMeal = mealBuilder.prepareVegMeal();
            System.out.println("Veg Meal");
            vegMeal.showItems();
            System.out.println("Total Cost: " + vegMeal.getCost());

            Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
            System.out.println("\n\nNon-Veg Meal");
            nonVegMeal.showItems();
            System.out.println("Total Cost: " + nonVegMeal.getCost());
        }

        /**
         * 商品基类
         */
        public interface Item {
            String name();

            Pack pack();

            float price();
        }

        /**
         * 包装者基类
         */
        public interface Pack {
            String pack();
        }

        public class Wrapper implements Pack {

            @Override
            public String pack() {
                return "Wrapper";
            }
        }

        public class Bottle implements Pack {
            @Override
            public String pack() {
                return "Bottle";
            }
        }

        public abstract class Burger implements Item {

            @Override
            public Pack pack() {
                return new Wrapper();
            }

            @Override
            public abstract float price();
        }

        public abstract class ColdDrink implements Item {

            @Override
            public Pack pack() {
                return new Bottle();
            }

            @Override
            public abstract float price();
        }

        public class VegBurger extends Burger {

            @Override
            public float price() {
                return 25.0f;
            }

            @Override
            public String name() {
                return "Veg Burger";
            }
        }

        public class ChickenBurger extends Burger {

            @Override
            public float price() {
                return 50.5f;
            }

            @Override
            public String name() {
                return "Chicken Burger";
            }
        }

        public class Coke extends ColdDrink {

            @Override
            public float price() {
                return 30.0f;
            }

            @Override
            public String name() {
                return "Coke";
            }
        }

        public class Pepsi extends ColdDrink {

            @Override
            public float price() {
                return 35.0f;
            }

            @Override
            public String name() {
                return "Pepsi";
            }
        }

        public class Meal {
            private List<Item> items = new ArrayList<Item>();

            public void addItem(Item item) {
                items.add(item);
            }

            public float getCost() {
                float cost = 0.0f;
                for (Item item : items) {
                    cost += item.price();
                }
                return cost;
            }

            public void showItems() {
                for (Item item : items) {
                    System.out.print("Item : " + item.name());
                    System.out.print(", Packing : " + item.pack().pack());
                    System.out.println(", Price : " + item.price());
                }
            }
        }

        public class MealBuilder {

            public Meal prepareVegMeal() {
                Meal meal = new Meal();
                meal.addItem(new VegBurger());
                meal.addItem(new Coke());
                return meal;
            }

            public Meal prepareNonVegMeal() {
                Meal meal = new Meal();
                meal.addItem(new ChickenBurger());
                meal.addItem(new Pepsi());
                return meal;
            }
        }
    }


    /**
     * 不使用设计模式的代码编写  后续有些问题 不再修改
     */
    public class requireMentImp {
        public Burger burger = new Burger();
        private Drink drink = new Drink();
        private Pack pack = new Pack();

        public void packageKFC() {
            this.burger = new VegBurger();
            this.drink = new Coffice();
            this.pack = new Pack();
        }

        /**
         * 素食汉堡
         */
        public class VegBurger extends Burger {
        }

        /**
         * 鸡肉汉堡
         */
        public class ChickenBurger extends Burger {
        }

        /**
         * 汉堡
         */
        public class Burger extends BaseCommoodity {
        }

        /**
         * 咖啡
         */
        public class Coffice extends Drink {
        }

        /**
         * 可口可乐
         */
        public class Coke extends Drink {
        }

        /**
         * 饮品
         */
        public class Drink extends BaseCommoodity {
        }

        /**
         * 塑料袋
         */
        public class PlasticBag extends Pack {
        }

        /**
         * 纸盒
         */
        public class Carton extends Pack {
        }

        /**
         * 包装盒
         */
        public class Pack extends BaseCommoodity {
        }

        /**
         * 商品基类
         */
        public class BaseCommoodity {
            private String name;
            private String price;

            private void setName() {
            }

            ;

            private void setprice() {
            }

            ;

        }
    }
}

```
## 12原型模式

copy的菜鸟教程，写的比较清晰，我就不画蛇添足了。 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。 这种模式是**
实现了一个原型接口，该接口用于创建当前对象的克隆**。当**直接创建对象的代价比较大**
时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
**主要解决：**在运行期建立和删除原型。
**何时使用：**
1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。
4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。
**关键代码：** 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone()
方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。
**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。
**优点：** 1、性能提高。 2、逃避构造函数的约束（说的好听，其实就是clone一份）。
**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 **Cloneable（原型接口）**
接口。
**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone
的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。
**注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。
```
import java.util.Hashtable;

/**
 * @author zhou
 * @since 2023/10/19
 * description:  设计模式-原型工厂-本身属于创建性工厂，做法是接口实现对对象的拷贝,可节省内存和频繁构建对象。
 */
public class PrototypePlant {
    /**
     * 克隆基类
     */
    public abstract class Shape implements Cloneable {
        private String id;
        protected String type;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        abstract void draw();

        @Override
        public Object clone() {
            Object clone = null;
            try {
                clone = super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return clone;
        }
    }

    /**
     * 实现基类
     */
    public class Rectangle extends Shape {
        public Rectangle() {
            this.type = "Rectangle";
        }

        @Override
        public void draw() {
            System.out.println("Inside Rectangle::draw() method.");
        }
    }

    public class Square extends Shape {

        public Square() {
            type = "Square";
        }

        @Override
        public void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }

    public class Circle extends Shape {

        public Circle() {
            type = "Circle";
        }

        @Override
        public void draw() {
            System.out.println("Inside Circle::draw() method.");
        }
    }

    /**
     * 构建缓存类
     */
    public class ShapeCache {

        private Hashtable<String, Shape> shapeMap
                = new Hashtable<String, Shape>();

        public Shape getShape(String shapeId) {
            Shape cachedShape = shapeMap.get(shapeId);
            return (Shape) cachedShape.clone();
        }

        // 对每种形状都运行数据库查询，并创建该形状
        // shapeMap.put(shapeKey, shape);
        // 例如，我们要添加三种形状
        public void loadCache() {
            Circle circle = new Circle();
            circle.setId("1");
            shapeMap.put(circle.getId(), circle);

            Square square = new Square();
            square.setId("2");
            shapeMap.put(square.getId(), square);

            Rectangle rectangle = new Rectangle();
            rectangle.setId("3");
            shapeMap.put(rectangle.getId(), rectangle);
        }
    }

    /**
     * 测试类
     */
    public class PrototypePatternDemo {
        public void test() {
            ShapeCache shapeCache = new ShapeCache();
            shapeCache.loadCache();

            Shape clonedShape = (Shape) shapeCache.getShape("1");
            System.out.println("Shape : " + clonedShape.getType());

            Shape clonedShape2 = (Shape) shapeCache.getShape("2");
            System.out.println("Shape : " + clonedShape2.getType());

            Shape clonedShape3 = (Shape) shapeCache.getShape("3");
            System.out.println("Shape : " + clonedShape3.getType());
        }
    }
}

```
## 13享元模式

享元模式（Flyweight Pattern）主要用于**减少创建对象的数量**
，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。（类似于缓存技术，提高对象的复用性，比如常见的数据库缓存池）
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 _Circle_ 对象。
**意图：**运用共享技术有效地支持大量细粒度的对象。
**主要解决：**在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。
5、系统不依赖于这些对象身份，这些对象是不可分辨的。
**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
**关键代码：**用 HashMap 存储这些对象。
**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的连接池。
**优点：**大大**减少对象的创建**，降低系统的内存，使效率提高。
**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。
**使用场景：** 1、系统有大量相似对象。 2、需要缓冲池的场景。
**注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。
```
import java.util.HashMap;

/**
 * @author zhou
 * @since 2023/10/19
 * description: 设计模式-享元模式
 * 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。
 * ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一
 * 个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，
 * 如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。
 */
public class EnyuanMode {

    public class EnyuanFactory() {
        private HashMap<Integer, Shape> cache = new HashMap<int, Shape>();

        public Shape getShape(int id) {
            if (cache.containsKey(id)) {
                return cache.get(id);
            } else {
                Cirle cirle = new Cirle();
                cache.put(id, cirle);
                return cirle;
            }
        }
    }

    public interface Shape {
        int id();

        String name();
    }

    public class Cirle implements Shape {

        @Override
        public int id() {
            return 1;
        }

        @Override
        public String name() {
            return "big";
        }
    }
}
```
## 14代理模式

**意图：**为其他对象提供一种代理以**控制对这个对象的访问**。
**主要解决：**
在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
**何时使用：**想在访问一个类时做一些控制。
**如何解决：**增加中间层。
**关键代码：**实现与被代理类组合。
**应用实例：**
1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。
3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。
**优点：**
1、职责清晰。 2、高扩展性。 3、智能化。
**缺点：**
1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。
7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。
**注意事项：**
1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
```
/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式-代理模式
 */
public class ProxyPattern {

    public interface image {
        void display();
    }

    public class RealImage implements image {

        @Override
        public void display() {
            System.out.println("我显示了");
        }
    }

    public class ProxyImage implements image {
        /**
         * 实现代理
         */
        @Override
        public void display() {
            RealImage image = new RealImage();
            image.display();
        }
    }


}
```
## 15桥接模式

桥接（Bridge）是用于把**抽象化与实现化解耦，使得二者可以独立变化**。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。
桥接模式的目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。 我们通过下面的实例来演示桥接模式（Bridge
Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。
**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。
**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。
**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。
**关键代码：**抽象类依赖实现类。
**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。
2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。
**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。
**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。
2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
**注意事项：**对于两个独立变化的维度，使用桥接模式再适合不过了。 以下是桥接模式的几个关键角色：

- 抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
- 扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
- 实现（Implementor）：定义实现接口，提供基本操作的接口。
- 具体实现（Concrete Implementor）：实现实现接口的具体类。
```
/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式- 桥接模式
 */
public class BridgingMode {
    public abstract class Shape {
        protected DrawAPI drawApi;

        protected Shape(DrawAPI drawApi) {
            this.drawApi = drawApi;
        }

        abstract void draw();

    }


    public interface DrawAPI {
        public void drawCircle(int radius, int x, int y);
    }

    public class Circle extends Shape {
        private int x, y, radius;

        public Circle(int x, int y, int radius, DrawAPI drawAPI) {
            super(drawAPI);
            this.x = x;
            this.y = y;
            this.radius = radius;
        }

        @Override
        void draw() {
            drawApi.drawCircle(x, y, radius);
        }
    }

    public class RedCircle implements DrawAPI {

        @Override
        public void drawCircle(int radius, int x, int y) {
            System.out.println("我是红色的圆");
        }

        ;
    }

    public class BlackCircle implements DrawAPI {
        @Override
        public void drawCircle(int radius, int x, int y) {
            System.out.println("我是黑色的圆");
        }
    }
}
```
上述这个例子表明先设计抽象类图形，然后在扩展对应的抽象实现类圆，交给我们的桥接接口去实现具体的实现类（红圆、黑圆）简单的来说其实就是实体化类用一个接口去衔接具体的抽象化类 ，使得双方修改的同时并不会影响到对方。
## 16组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。
**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。
**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。
**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container
是树枝。
**优点：** 1、高层模块调用简单。 2、节点自由增加。
**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。
**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。
**注意事项：**定义时为具体类。 说白了类似于老师这个类里面有自己学生的集合。
```
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式-组合模式
 */
public class Combination {

    public class Student {
        private String name;
        private String age;
    }

    public class Teacher {
        private String name;
        private String age;
        private List<Student> studentList;
    }
}
```
## 17迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。
**意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
**主要解决：**不同的方式来遍历整个整合对象。
**何时使用：**遍历一个聚合对象。
**如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。
**关键代码：**定义接口：hasNext, next。
**应用实例：**JAVA 中的 iterator。
**优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
**缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
**使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。
**注意事项：**迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
```
/**
 * @author zhou
 * @since 2023/10/20
 * description: 设计模式-迭代器模式
 */
public class Iterator {
    public static void main(String[] args) {

        NameRepository repository = new Iterator.NameRepository();
        for (TestIterator iterator = repository.getIterator(); iterator.hasNext(); ) {
            System.out.println(iterator.next());
        }
    }

    void test() {
        NameRepository repository = new NameRepository();
        for (TestIterator iterator = repository.getIterator(); iterator.hasNext(); ) {
            System.out.println(iterator.next());
        }
    }

    public interface TestIterator {
        boolean hasNext();

        Object next();
    }

    public interface Container {
        public TestIterator getIterator();
    }

    public static class NameRepository implements Container {
        public String[] names = {"Robert", "John", "Julie", "Lora"};

        @Override
        public TestIterator getIterator() {
            return new NameIterator();
        }

        private class NameIterator implements TestIterator {

            int index;

            @Override
            public boolean hasNext() {
                if (index < names.length) {
                    return true;
                }
                return false;
            }

            @Override
            public Object next() {
                if (this.hasNext()) {
//                    这里会有疑惑为什么迭代器不会跳过第一个元素 是因为index++会先使用index值在进行累加 而++index先进行累加在赋值
                    return names[index++];
                }
                return null;
            }
        }
    }
}
```

## 18中介者模式

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。
**意图：用一个中介对象来封装一系列的对象交互**，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
**主要解决：**对象与对象之间存在大量的**关联**关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
**何时使用：**多个类相互耦合，形成了网状结构。
**如何解决：**将上述网状结构分离为星型结构。
**关键代码：**对象 Colleague 之间的通信封装到一个类中单独处理。
**应用实例：** 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。
**缺点：**中介者会庞大，变得复杂难以维护。
**使用场景：** 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。
**注意事项：**不应当在职责混乱的时候使用。

```
import javax.print.attribute.standard.Media;

/**
 * @author zhou
 * @since 2023/10/23
 * description: 中介者模式
 * 用一个中介对象来封装一系列的对象交互
 */
public class Mediator {
    public static void main(String[] args) {
        Mediator media = new Mediator();
        media.test();
    }
    public void test(){
        User user = new User("1", "我是测试类");
        user.shoMessage();
    }
    /**
     * 中介类
     */
    public static class Intermediary{

        public static void showMessage(User user, String message){
            System.out.println("当前发送消息的人"+user.getName()+",消息是"+message);
        }

    }

    public class  User{
        public User(String name, String message) {
            this.name = name;
            this.message = message;
        }
        private String name;
        private String message;
        public void shoMessage(){
            Intermediary.showMessage(this,message);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }
}
```

## 19备忘录模式

备忘录模式（Memento Pattern）**保存一个对象的某个状态**，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
**意图：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
**主要解决：**所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
**何时使用：**很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。
**如何解决：**通过一个备忘录类专门存储对象状态。
**关键代码：**客户不与备忘录类耦合，与备忘录管理类耦合。
**应用实例：** 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。
**优点：** 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。
**缺点：**消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
**使用场景：** 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。
**注意事项：** 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。

```
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/23
 * description: 设计模式-备忘录模式
 */
public class Memento {
    public static void main(String[] args) {
        Memento memento = new Memento();
        memento.test();
    }

    public void test(){
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState("State #1");
        originator.setState("State #2");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #3");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #4");

        System.out.println("Current State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved State: " + originator.getState());
    };
    /**
     * 当前对象的状态
     */
    public class MementoState {
        private String state;

        public MementoState(String state) {
            this.state = state;
        }

        public String getState() {
            return state;
        }
    }

    /**
     * 创建存储对象
     */
    public class Originator {
        private String state;

        public void setState(String state) {
            this.state = state;
        }

        public String getState() {
            return state;
        }

        public MementoState saveStateToMemento() {
            return new MementoState(state);
        }

        public void getStateFromMemento(MementoState Memento) {
            state = Memento.getState();
        }
    }

    /**
     * 保存历史记录
     */
    public class CareTaker {
        private List<MementoState> mementoList = new ArrayList<MementoState>();

        public void add(MementoState state) {
            mementoList.add(state);
        }

        public MementoState get(int index) {
            return mementoList.get(index);
        }
    }
}
```

使用类将对象存储起来。

## 20解释器模式

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
**意图：**给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
**主要解决：**对于一些固定文法构建一个解释句子的解释器。
**何时使用：**如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
**如何解决：**构建语法树，定义终结符与非终结符。
**关键代码：**构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。
**应用实例：**编译器、运算表达式计算。
**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。
**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。
**使用场景：** 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。
**注意事项：**可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 简单来说就是定义接口，然后实现类去解释接口定义的行为。

```
/**
 * @author zhou
 * @since 2023/10/23
 * description: 设计模式-解释器模式
 */
public class InterpreterPattern {
    public interface Expression {
        void count(int a, int b);
    }

    /**
     * 加法解释器
     */
    public class Addition implements Expression {

        @Override
        public void count(int a, int b) {
            System.out.println(a + b);
        }
    }

    /**
     * 减法解释器
     */
    public class Subtraction implements Expression {

        @Override
        public void count(int a, int b) {
            System.out.println(a - b);
        }
    }
}

```

## 21责任链模式

顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
**何时使用：**在处理消息的时候以过滤很多道。
**如何解决：**拦截的类都实现统一接口。
**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。
**应用实例：** 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。
**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。
**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。
**使用场景：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。
**注意事项：**在 JAVA WEB 中遇到很多应用。

```
/**
 * @author zhou
 * @since 2023/10/23
 * description: 设计模式-责任链模式
 */
public class ChainOfResponsibilityPattern {
    public static void main(String[] args) {
        ChainOfResponsibilityPattern chain = new ChainOfResponsibilityPattern();
        chain.test();
    }

    public void test() {
        ErrorLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
        InfoLogger infoLogger = new InfoLogger(AbstractLogger.INFO);
        ConsoleLogger consoleLogger = new ConsoleLogger(AbstractLogger.CONSOLE);
        infoLogger.setNextAbstractLogger(consoleLogger);
        errorLogger.setNextAbstractLogger(infoLogger);

        errorLogger.loadMessage(AbstractLogger.INFO,"你好,我是测试日志");
    }

    public abstract static class AbstractLogger {
        private static Integer CONSOLE = 1;
        private static Integer INFO = 2;
        private static Integer ERROR = 3;
        protected Integer level;
        private AbstractLogger nextAbstractLogger;

        public Integer getLevel() {
            return level;
        }

        public void setLevel(Integer level) {
            this.level = level;
        }

        public AbstractLogger getNextAbstractLogger() {
            return nextAbstractLogger;
        }

        public void setNextAbstractLogger(AbstractLogger nextAbstractLogger) {
            this.nextAbstractLogger = nextAbstractLogger;
        }

        public void loadMessage(Integer level, String message) {
            if (level <= this.getLevel()) {
                write(message);
            }
            if (nextAbstractLogger != null) {
                nextAbstractLogger.loadMessage(level, message);
            }
        }

        public abstract void write(String meassage);
    }

    public class ConsoleLogger extends AbstractLogger {

        public ConsoleLogger(Integer level) {
            this.level = level;
        }

        @Override
        public void write(String massage) {
            System.out.println("console日志消息为" + massage);
        }
    }

    public class InfoLogger extends AbstractLogger {

        public InfoLogger(Integer level) {
            this.level = level;
        }

        @Override
        public void write(String massage) {
            System.out.println("Info日志消息为" + massage);
        }
    }

    public class ErrorLogger extends AbstractLogger {

        public ErrorLogger(Integer level) {
            this.level = level;
        }

        @Override
        public void write(String massage) {
            System.out.println("Error日志消息为" + massage);
        }
    }
}
```

会将符合相关条件的信息一直传递下去。

## 22访问者模式

在访问者模式（Visitor
Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
**意图：**主要将数据结构与数据操作分离。
**主要解决：**稳定的数据结构和易变的操作耦合问题。
**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。
**如何解决：**在被访问的类里面加一个对外提供接待访问者的接口。
**关键代码：**在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。
**应用实例：**您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。
**优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。
**缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
**使用场景：** 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。
**注意事项：**访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

```
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhou
 * @since 2023/10/23
 * description: 设计模式-访问者模式
 * 不改变原有对象的算法或者数据 可以看到下面关于洗漱相关的步骤我们都交给了访问者的接口去定义具体的步骤
 */
public class VisitorPattern {
    public static void main(String[] args) {
        VisitorPattern pattern = new VisitorPattern();
        pattern.test();
    }

    public void test() {
        WashUp washUp = new WashUp();
        washUp.execute(new VisitorImp());
    }

    /**
     * 洗漱基类
     */
    public interface WashUpPart {
        void execute(Visitor visitor);
    }

    /**
     * 洗脸
     */
    public class WashYourFace implements WashUpPart {
        @Override
        public void execute(Visitor visitor) {
            visitor.execute(this);
        }
    }

    /**
     * 刷牙
     */
    public class BrushTeeth implements WashUpPart {
        @Override
        public void execute(Visitor visitor) {
            visitor.execute(this);
        }
    }

    public class WashUp implements WashUpPart {
        private List<WashUpPart> partList = new ArrayList<WashUpPart>();

        public WashUp() {
            partList.add(new BrushTeeth());
            partList.add(new WashYourFace());
        }

        @Override
        public void execute(Visitor visitor) {
            partList.forEach(part -> {
                part.execute(visitor);
            });
            visitor.execute(this);

        }
    }

    public interface Visitor {
        void execute(WashYourFace washYourFace);

        void execute(BrushTeeth brushTeeth);

        void execute(WashUp washUp);

    }

    public class VisitorImp implements Visitor {

        @Override
        public void execute(WashYourFace washYourFace) {
            System.out.println("自定义洗脸方式-我在洗脸");
        }

        @Override
        public void execute(BrushTeeth brushTeeth) {
            System.out.println("自定义刷牙方式-我在刷牙");
        }

        @Override
        public void execute(WashUp washUp) {
            System.out.println("自定义洗漱方式-我在洗漱");
        }
    }
}

```
