# Mysql高级认识



## 1mysql8.0以前及以后字符集规则及原理

- mysql8.0之前：字符集Latin1
- mysql8.0以后：字符集utf8MP4

### 1.1字符规则

- ut8MP3使用1到3个字节（阉割版utf8  常见mysql8.0以前）
- utfmp4使用1到4个字节（完整版utf8）



## 2sql_mode的使用

### 2.1**什么是sql_mode?**

sql_ mode 会影响MySQL支持的SQL语法以及它执行的‘数据验证检查。通过设置sqL mode,可以完成不同严格程度的数据校验，有效地保障数据准确性。
MySQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于**sqL mode**系统变量的值。



### 2.2宽松模式vs严格模式

举例如下： 存储一条数据nam为“12345678910aaa”  char（10）的数据

宽松模式：自动截取数据索引到10的位置   不会报错。

严格模式： 进行报错



## 3数据库数据与文件系统的关系

### 3.1什么是文件系统?

像InnoDB、MyISAM 这样的存储弓|肇都是把表存储在磁盘上的,操作系统用来管理磁盘的结构被称为**文件系统**，所以用专业一点的话来表述就是:像InnoDB、MyISAM 这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储弓|擎会把这些数据又写回文件系统。本章学习一下 InnoDB和MyISAM这两个存储引擎的数据如何在文件系统中存储。







## 4用户管理

mysql分为普通用户和root用户.

创建用户

```
create   user  用户名 identified by 'password';  
```

修改用户(本质上是修改mysql.user表)

```

```

删除用户

```
drop  user  'username';
set password 'new Password';
```

修改密码

- 用户登陆下修改自己的密码

```
alter user user()  identfixed  by "password";
```



- 权限高的用户修改别人的密码

```

```



## 5权限管理

查看个人权限

```
show   grants;
```

用户授权

grant     select,updat    on   数据库名    to 用户名  ;



### 5.1授予权限的原则

权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：

1. 只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给选择权限就可以了，不要给用户赋予update、insert或者delete权限。要给用户赋予更新、插入或者删除权限。
2. 创建用户的时候限制用户的登录主机，- -般是限制成指定IP或者内网IP段。
3. 为每个用户设置满足密码复杂度的密码。
4. 定期清理 不需要的用户，回收权限或者删除用户。





## 6sql执行流程

![image-20220616185220710](http://inis.inis1719.cn/202206161852841.png)



- 1查询缓存
- 2解析器(解析语法)
- 3优化器  确定sq查询的最优策略
- 4存储引擎返回结果



## 7数据库缓冲池vs查询缓存

内层级别的数据缓冲 j叫做数据库缓冲池   目的是为了减少磁盘的io操作。

其中innodb引擎以页为基本单位加载  一页的大小为16kb；



### **7.1缓存原则**

会优先对使用频率比较高的热数据缓存。

### 7.2缓存池预读数据

可以预先将引擎的页数据缓存到内存中。

### 7.3数据库缓存池与查询缓存的区别

查询缓存是将查询结果缓存起来 下次直接得到结果   

数据库缓存池是将一页数据缓存起来。



## 8存储引擎

查看数据库引擎

```
show engines;
```

### 8.1InnoDB引擎

具有外键支持功能的事务存储引擎

使用场景：

数据量大并且需要事务。

表名.frn  存储表结构

表名.iba  存储数据和索引

### 8.2MyISAM

缺点 ：不支持事务  崩溃后无法安全恢复

优势：访问速度快。

![image-20220616200722909](http://inis.inis1719.cn/202206162007854.png)

### 8.3Archive

用于数据归档   仅仅支持插入和查看。使用行级锁。

使用场景：

适合存储大量的日志和历史数据。

### 8.4  Blackhole引擎

没有任何保存机制     会丢弃所有插入的数据

### 8.5CSV引擎

作为一种数据交换（列如 json  、xml）的机制。

### 8.6 Memiry引擎

数据存储到内存当中  当进程崩溃的时候数据丢失。

## 9索引

### 9.1为什么建立索引？

索引是存储引擎用于快速找到数据记录的- -种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一 样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要-条-条地查找记录，直到找到与条件符合的记录。

**为什么要建立索引？**

减少磁盘io操作  innodb引擎数据文件存储在磁盘上。

**索引的优缺点？**

- 优点：

1. 快速查找数据
2. 减少磁盘io
3. 加速表连接

- 缺点：

1. 维护索引耗费时间
2. 索引需要占用磁盘空间（Innodb引擎将索引和表数据一起存储  后缀为fro）
3. 降低了更新表的速度（更新了磁盘数据同时也要维护索引的数据）



### 9.2设计索引

引出案例如下：

![image-20220616204039391](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220616204039391.png)

以页面开头记录项id为一组数组 然后使用二分查找确定在那一页中 在使用二分查找去匹配页数据。

  按照上图所示的话如果我插入一条主键为11的数据的话就会新创建一页 然后绑定前一页地址和后一页地址（这样一个数据就会占据一页   成本较大  所以我们开始迭代）

**索引迭代方案**

迭代第一次将目录项放在目录页中

![image-20220616205130636](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220616205130636.png)



目录项记录和数据项记录的异同：

- 相同：

1. 目录页的record_type值为1     而普通记录为0
2. 目录项只有主键值和页的编号    而用户记录可自定义

- 不同：

1. 使用相同的数据页 都会为主键生成page Directory（页目录）

迭代效果：磁盘操作变为2次   第一次根据数据项id查询目录页  第二次找到指定数据页后记载

2迭代第二次（多个目录项）

![image-20220616205846085](http://inis.inis1719.cn/202206162058869.png)

由上引导出 数据结构**B+树

树的层数越低，io消耗越小。

其中  树的层级不会超过4  案例如下：

![image-20220616210232551](http://inis.inis1719.cn/202206162102330.png)



### 9.3常见索引

#### 9.3.1聚簇索引（数据记录有序）

  聚簇索引并不是一-种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是所谓的索引即数据，数据即索引。

**特点:**
1.使用记录主键值的大小进行记录和页的排序,这包括三个方面的含义:
页内的记录是按照主键的大小顺序排成一个单向链表.
各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表.
存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2.B+树的叶子 节点存储的是完整的用户记录。
所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)。



我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB 存引擎会自动的为我们创建聚簇索引。



优点：

数据访问更快，因为数据和索引在同一个b+树中。

缺点：

依赖插入顺序 需要保持有序。

限制：

每个表只有一个主键 

如果没有主键的话 ，innodb会自动选择一个非空字段/自动生成隐藏主键当作主键

   

#### 9.3.2非聚簇索引（ 辅助索引 二级索引     即叶子节点只储存主键    只不过还存储了对应数据节点的地址  然后进行回表查询）

![image-20220616211524322](http://inis.inis1719.cn/202206162115239.png)

回表：

当我们查询到具体的数据页中的数据时发现表中改的某个字段存储在目录页中   于是我们就需要返回去查 这就叫做回表。

问题:

为什么我们还需要-次回表操作呢?直接把完整的用户记录放到叶子节点不OK吗?
回答:
如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了,相当于每建立-棵B+树都需要把所有的用户记录再都拷贝-遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引(英文名 secondary index) ，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引.非聚簇索引的存在不影响数据在聚簇索引中的组织，所以-一张表可以有多个非聚簇索引。



#### 9.3.3联合索引（也是非聚簇索引  即存在多个主键项）

如图所示，我们需要注意以下几点:
●每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
●B+树叶子节点处的用户记录由c2、 c3和主键c1列组成。
注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:
●建立联合索引只会建立如上图-样的1棵B+树。
●为c2和c3列分别建立索引会分别以2和c3列的大小为排序规则建立2棵B+树。



### 9.4innodb的b+树索引注意事项

1根页面位置万年不变。

2内节点根目录项记录一致性。

3一个页面最少存储2条记录。

### 9.5MyISAM的索引方案

MyISAM叶子节点存放的是数据的地址 ，而innodb叶子节点存放的是数据。

MyISAM的索引与数据分开存储。

MyISAM没有聚簇索引  所以一定会进行一次**回表**操作。



### 9.6索引的创建与设计原则

#### 9.6.1索引的分类

**从功能逻辑上分为**

- 普通索引

不加任何限制条件   

- 唯一索引

创建唯一数据索引   unique  

- 主键索引（聚簇索引）

特殊的唯一索引  在唯一索引上增加了不为null

- 全文索引

目前搜索引擎最流行的方式  fulltext  适用于大数据字符串

**从物理实现方式分为**

- 聚簇索引
- 非聚簇索引

按照作用字段个数分为

- 单列索引

在表的单个字段上创建索引

- 联合索引

在表的多个字段组合上创建索引   索引指向表的多个字段  可以通过这几个字段查询  使用组合索引满足**最左前缀集合**



![image-20220621104425033](http://inis.inis1719.cn/202206211044883.png)



#### 9.6.2创建索引

alter table  修改表索引      

create   index   在已存在的表添加索引   //隐式创建索引

 drop   index                      //删除索引



8.0以后支持降级索引和隐藏索引

其中隐藏索引后面加    invisible即可

![image-20220621120014561](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220621120014561.png)



#### 9.6.3那些情况适合创建索引？

1. 字段数据具有唯一性
2. 平时被where条件使用到的字段
3. 经常group和order排序的字段
4. update 和  delete的where字段列
5. distinct去重字段   需要创建索引
6. 多表join连接操作时  创建索引注意(连接表尽量不要超过三张   对where 条件创建索引  对连接条件创建索引)
7. 使用列类型小的创建索引
8. 使用字符串前缀创建索引（如果字符串很长  就需要占用很大的空间    我们可以通过截取字符串前一部分来构建索引  这种创建索引叫前缀索引）
9. 区分度散列度高的适合创建索引（列的基数值指的是某一列中不重复的数据个数  可通过 select  count（distict  a）/count（*）  from  t1  来计算）
10. 使用最频繁的列放在联合索引的最左侧（最左前缀原则）
11. 在多个字段都需要创建索引时，优先创建联合索引



#### 9.6.4那些情况不适合索引？

1. where中不需要使用的列。
2. 数据量小的表不用创建索引。
3. 有大量重复数据的列上最好不要创建索引
4. 避免对经常更新的表去创建过多的索引.
5. 不建议使用无序的列作为索引.
6. 删除不经常使用的索引. 
7. 不定义冗余 重复的索引



### 9.7sql调优

#### 9.7.1查看系统预置参数

![image-20220621144345377](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220621144345377.png)



#### 9.7.2统计sql查询成本   last_query_cost

![image-20220621144915556](http://inis.inis1719.cn/202206211449577.png)

#### 9.7.3定位慢sql

即当sql执行时间超过阈值时被定义慢sql

默认情况下mysql的慢查询日志没有开启.

开启慢查询日志

```
show  variables like '%slow_query_log%';
set  global slow_query_log=on;
```

修改阈值

```
set  global   long_query_time=1;
```



![image-20220621150902976](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220621150902976.png)



#### 9.7.4Explain   sql分析语句

select_type   查询类型

table  表名

portitions  分区信息

type  执行查询时的访问方法   

![image-20220621155949265](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220621155949265.png)

possible_key  可能使用到的索引

key  实际使用的索引

key_len:实际使用到的索引长度  (针对于联合索引值越大越好)

ref:当使用索引列进行等值匹配时 的对象信息.

rows:  预估需要读取到的数据条数

filtred:查询到的数据占比  值越高越好

extra:  说明额外信息

![image-20220621163101426](http://inis.inis1719.cn/202206211631220.png)



explain输出格式

1. json格式  json
2. 传统格式   默认不输入
3. tree格式  tree
4. 可视化输出    

```
Explain  format=json/
```



#### 9.7.5trace分析优化器

#### 9.7.6  mysql监控分析视图   -sys schema

#### 9.7.7 关联查询和子查询的优化

join语句的原理









关联查询

- 左外连接

即筛选表的列加上索引

- 内连接

连接条件都可以加上索引

并且在两个表都存在索引的情况下 会有数据量小的表去驱动数据量大的表



子查询

where 列 都可以加上索引



### 9.8 索引失效的情况

- 不满足最左前缀原则
- 主键插入顺序
- where后面进行函数操作
- where后面进行计算
- 类型转换
- 范围条件索引右侧索引失效
- !=或者<>索引失效
- is not null不能使用索引    is  null  可以使用索引
- like模糊查询以%开头 不能确定索引
- or关键字 前后存在非索引的列 索引失效

![image-20220621203034944](http://inis.inis1719.cn/202206212030856.png)















## 10innodb的存储结构 （页）

页的大小为16kb。

页作为磁盘和内存交互的基本单位.数据库操作的最小单位是页

页和页之间用**双向链表**链接..

区(Extent) 是比页大一级的存储结构, 在InnoDB存储引擎中，-个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB= 1MB。

段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间 (在InnoDB中是连续的64个页) ,不过在段中不要求区与区之间是相邻的。段是 数据库中的**分配单位**，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段， 创建一个索引时会创建一个索引段。

表空间(Tablespace) 是一个逻辑容器，表空间存储的对象是**段**,在一个表空间中可以有一个或多个段,但是一个段只能属于一个表空间。数据库由一个或多个表空间组成,表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。



### 10.1页的内部结构(p121-125)

页如果按类型划分的话，常见的有数据页(保存B+树节点)、系统页、 Undo 页和事务数据页等。数据页是我们最常使用的页。
数据页的16KB大小的存储空间被划分为七个部分,分别是**文件头**(File Header)、**页头**(Page Header)、**最大最小记录**(Infimum+supremum) .**用户记录**(User Records) .**空闲空间**(Free Space)、**页目录**(Page Directory)和**文件尾**(File Tailer)

![image-20220617105934437](http://inis.inis1719.cn/202206171059684.png)



#### 10.1.1文件头尾部

![image-20220617110812708](http://inis.inis1719.cn/202206171108494.png)



#### 10.1.2 最大最小记录

![image-20220620205319231](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620205319231.png)



#### 10.1.3页面头部



### 10.2b+树是如何进行记录检索的？

从树的**根部**开始查询 直到找寻到叶子节点也就是数据页   再将**数据页**加载到**内存**中。  然后页目录的槽采用**二分查找**的方式找到粗略的记录分组  然后再通过单**链表**遍历的形式找出数据。



### 10.3 普通索引和唯一索引在查询效率上有什么不同？

普通索引查询到多条数据

唯一索引只能持续到一条数据。

### 10.4  innodb   行格式/记录格式

指定行格式：row_fomat

![image-20220620211906535](http://inis.inis1719.cn/202206202119419.png)

#### 10.4.1  Compact

![image-20220620211954290](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620211954290.png)

变长字段长度列表：即字段数据类型不是固定的 可自动扩容  

null值列表：   把为null的列统一记录起来 ，如果没有null值  也就不复存在。

为什么定义null列表：如果没有标注为null 那么查询出来的数据就会混乱  并且语句会报错

记录头i信息：  记录一些基本信息

另外行格式还有**Dynamic**和**Compressed **   与之不同的是处理行格式的方法不同

**Compact**处理行格式是 是将**溢出的数据**存入到溢出页中

**Dynamic**和**Compressed **   处理行格式是将数据**全部存储**到溢出页中  而数据只存储溢出页的地址。



### 10.5 行溢出

一个页的大小一般是16kb  也就是16*1024字节，但是varchar字节可存放65535个字节 所以就存在一个页放不下一条记录 这就叫行溢出。



### 10.6  区 、段、碎片区、表空间

**为什么需要区？**

读取的数据页可能不是连续的  所以就会发生**随机io**  增加数据缓冲的时间    所以我们体长**顺序io**    

![image-20220620221208541](http://inis.inis1719.cn/202206202212335.png)

**为什么需要段？**

区分叶子节点和非叶子节点。

 ![image-20220620221411906](http://inis.inis1719.cn/202206202214888.png)

**为什么需要碎片区？**

![image-20220620221831587](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620221831587.png)



区的分类：

![image-20220620222209355](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620222209355.png)



表空间

![image-20220620222308072](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620222308072.png)



