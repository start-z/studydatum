# Mysql高级认识



## 1mysql8.0以前及以后字符集规则及原理

- mysql8.0之前：字符集Latin1
- mysql8.0以后：字符集utf8MP4

### 1.1字符规则

- ut8MP3使用1到3个字节（阉割版utf8  常见mysql8.0以前）
- utfmp4使用1到4个字节（完整版utf8）



## 2sql_mode的使用

### 2.1**什么是sql_mode?**

sql_ mode 会影响MySQL支持的SQL语法以及它执行的‘数据验证检查。通过设置sqL mode,可以完成不同严格程度的数据校验，有效地保障数据准确性。
MySQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于**sqL mode**系统变量的值。



### 2.2宽松模式vs严格模式

举例如下： 存储一条数据nam为“12345678910aaa”  char（10）的数据

宽松模式：自动截取数据索引到10的位置   不会报错。

严格模式： 进行报错



## 3数据库数据与文件系统的关系

### 3.1什么是文件系统?

像InnoDB、MyISAM 这样的存储弓|肇都是把表存储在磁盘上的,操作系统用来管理磁盘的结构被称为**文件系统**，所以用专业一点的话来表述就是:像InnoDB、MyISAM 这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储弓|擎会把这些数据又写回文件系统。本章学习一下 InnoDB和MyISAM这两个存储引擎的数据如何在文件系统中存储。







## 4用户管理

mysql分为普通用户和root用户.

创建用户

```
create   user  用户名 identified by 'password';  
```

修改用户(本质上是修改mysql.user表)

```

```

删除用户

```
drop  user  'username';
set password 'new Password';
```

修改密码

- 用户登陆下修改自己的密码

```
alter user user()  identfixed  by "password";
```



- 权限高的用户修改别人的密码

```

```



## 5权限管理

查看个人权限

```
show   grants;
```

用户授权

grant     select,updat    on   数据库名    to 用户名  ;



### 5.1授予权限的原则

权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：

1. 只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给选择权限就可以了，不要给用户赋予update、insert或者delete权限。要给用户赋予更新、插入或者删除权限。
2. 创建用户的时候限制用户的登录主机，- -般是限制成指定IP或者内网IP段。
3. 为每个用户设置满足密码复杂度的密码。
4. 定期清理 不需要的用户，回收权限或者删除用户。





## 6sql执行流程

![image-20220616185220710](http://inis.inis1719.cn/202206161852841.png)



- 1查询缓存
- 2解析器(解析语法)
- 3优化器  确定sq查询的最优策略
- 4存储引擎返回结果



## 7数据库缓冲池vs查询缓存

内层级别的数据缓冲 j叫做数据库缓冲池   目的是为了减少磁盘的io操作。

其中innodb引擎以页为基本单位加载  一页的大小为16kb；



### **7.1缓存原则**

会优先对使用频率比较高的热数据缓存。

### 7.2缓存池预读数据

可以预先将引擎的页数据缓存到内存中。

### 7.3数据库缓存池与查询缓存的区别

查询缓存是将查询结果缓存起来 下次直接得到结果   

数据库缓存池是将一页数据缓存起来。



## 8存储引擎

查看数据库引擎

```
show engines;
```

### 8.1InnoDB引擎

具有外键支持功能的事务存储引擎

使用场景：

数据量大并且需要事务。

表名.frn  存储表结构

表名.iba  存储数据和索引

### 8.2MyISAM

缺点 ：不支持事务  崩溃后无法安全恢复

优势：访问速度快。

![image-20220616200722909](http://inis.inis1719.cn/202206162007854.png)

### 8.3Archive

用于数据归档   仅仅支持插入和查看。使用行级锁。

使用场景：

适合存储大量的日志和历史数据。

### 8.4  Blackhole引擎

没有任何保存机制     会丢弃所有插入的数据

### 8.5CSV引擎

作为一种数据交换（列如 json  、xml）的机制。

### 8.6 Memiry引擎

数据存储到内存当中  当进程崩溃的时候数据丢失。

## 9索引

### 9.1为什么建立索引？

索引是存储引擎用于快速找到数据记录的- -种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一 样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要-条-条地查找记录，直到找到与条件符合的记录。

**为什么要建立索引？**

减少磁盘io操作  innodb引擎数据文件存储在磁盘上。

**索引的优缺点？**

- 优点：

1. 快速查找数据
2. 减少磁盘io
3. 加速表连接

- 缺点：

1. 维护索引耗费时间
2. 索引需要占用磁盘空间（Innodb引擎将索引和表数据一起存储  后缀为fro）
3. 降低了更新表的速度（更新了磁盘数据同时也要维护索引的数据）



### 9.2设计索引

引出案例如下：

![image-20220616204039391](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220616204039391.png)

以页面开头记录项id为一组数组 然后使用二分查找确定在那一页中 在使用二分查找去匹配页数据。

  按照上图所示的话如果我插入一条主键为11的数据的话就会新创建一页 然后绑定前一页地址和后一页地址（这样一个数据就会占据一页   成本较大  所以我们开始迭代）

**索引迭代方案**

迭代第一次将目录项放在目录页中

![image-20220616205130636](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220616205130636.png)



目录项记录和数据项记录的异同：

- 相同：

1. 目录页的record_type值为1     而普通记录为0
2. 目录项只有主键值和页的编号    而用户记录可自定义

- 不同：

1. 使用相同的数据页 都会为主键生成page Directory（页目录）

迭代效果：磁盘操作变为2次   第一次根据数据项id查询目录页  第二次找到指定数据页后记载

2迭代第二次（多个目录项）

![image-20220616205846085](http://inis.inis1719.cn/202206162058869.png)

由上引导出 数据结构**B+树

树的层数越低，io消耗越小。

其中  树的层级不会超过4  案例如下：

![image-20220616210232551](http://inis.inis1719.cn/202206162102330.png)



### 9.3常见索引

#### 9.3.1聚簇索引（数据记录有序）

  聚簇索引并不是一-种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是所谓的索引即数据，数据即索引。

**特点:**
1.使用记录主键值的大小进行记录和页的排序,这包括三个方面的含义:
页内的记录是按照主键的大小顺序排成一个单向链表.
各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表.
存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2.B+树的叶子 节点存储的是完整的用户记录。
所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)。



我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB 存引擎会自动的为我们创建聚簇索引。



优点：

数据访问更快，因为数据和索引在同一个b+树中。

缺点：

依赖插入顺序 需要保持有序。

限制：

每个表只有一个主键 

如果没有主键的话 ，innodb会自动选择一个非空字段/自动生成隐藏主键当作主键

   

#### 9.3.2非聚簇索引（ 辅助索引 二级索引     即叶子节点只储存主键    只不过还存储了对应数据节点的地址  然后进行回表查询）

![image-20220616211524322](http://inis.inis1719.cn/202206162115239.png)

回表：

当我们查询到具体的数据页中的数据时发现表中改的某个字段存储在目录页中   于是我们就需要返回去查 这就叫做回表。

问题:

为什么我们还需要-次回表操作呢?直接把完整的用户记录放到叶子节点不OK吗?
回答:
如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了,相当于每建立-棵B+树都需要把所有的用户记录再都拷贝-遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引(英文名 secondary index) ，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引.非聚簇索引的存在不影响数据在聚簇索引中的组织，所以-一张表可以有多个非聚簇索引。



#### 9.3.3联合索引（也是非聚簇索引  即存在多个主键项）

如图所示，我们需要注意以下几点:
●每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
●B+树叶子节点处的用户记录由c2、 c3和主键c1列组成。
注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:
●建立联合索引只会建立如上图-样的1棵B+树。
●为c2和c3列分别建立索引会分别以2和c3列的大小为排序规则建立2棵B+树。



### 9.4innodb的b+树索引注意事项

1根页面位置万年不变。

2内节点根目录项记录一致性。

3一个页面最少存储2条记录。

### 9.5MyISAM的索引方案

MyISAM叶子节点存放的是数据的地址 ，而innodb叶子节点存放的是数据。

MyISAM的索引与数据分开存储。

MyISAM没有聚簇索引  所以一定会进行一次**回表**操作。



### 9.6索引的创建与设计原则



## 10innodb的存储结构 （页）

页的大小为16kb。

页作为磁盘和内存交互的基本单位.数据库操作的最小单位是页

页和页之间用**双向链表**链接..

区(Extent) 是比页大一级的存储结构, 在InnoDB存储引擎中，-个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB= 1MB。

段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间 (在InnoDB中是连续的64个页) ,不过在段中不要求区与区之间是相邻的。段是 数据库中的**分配单位**，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段， 创建一个索引时会创建一个索引段。

表空间(Tablespace) 是一个逻辑容器，表空间存储的对象是**段**,在一个表空间中可以有一个或多个段,但是一个段只能属于一个表空间。数据库由一个或多个表空间组成,表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。



### 10.1页的内部结构(p121-125)

页如果按类型划分的话，常见的有数据页(保存B+树节点)、系统页、 Undo 页和事务数据页等。数据页是我们最常使用的页。
数据页的16KB大小的存储空间被划分为七个部分,分别是**文件头**(File Header)、**页头**(Page Header)、**最大最小记录**(Infimum+supremum) .**用户记录**(User Records) .**空闲空间**(Free Space)、**页目录**(Page Directory)和**文件尾**(File Tailer)

![image-20220617105934437](http://inis.inis1719.cn/202206171059684.png)



#### 10.1.1文件头尾部

![image-20220617110812708](http://inis.inis1719.cn/202206171108494.png)



#### 10.1.2 最大最小记录

![image-20220620205319231](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620205319231.png)



#### 10.1.3页面头部



### 10.2b+树是如何进行记录检索的？

从树的**根部**开始查询 直到找寻到叶子节点也就是数据页   再将**数据页**加载到**内存**中。  然后页目录的槽采用**二分查找**的方式找到粗略的记录分组  然后再通过单**链表**遍历的形式找出数据。



### 10.3 普通索引和唯一索引在查询效率上有什么不同？

普通索引查询到多条数据

唯一索引只能持续到一条数据。

### 10.4  innodb   行格式/记录格式

指定行格式：row_fomat

![image-20220620211906535](http://inis.inis1719.cn/202206202119419.png)

#### 10.4.1  Compact

![image-20220620211954290](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620211954290.png)

变长字段长度列表：即字段数据类型不是固定的 可自动扩容  

null值列表：   把为null的列统一记录起来 ，如果没有null值  也就不复存在。

为什么定义null列表：如果没有标注为null 那么查询出来的数据就会混乱  并且语句会报错

记录头i信息：  记录一些基本信息

另外行格式还有**Dynamic**和**Compressed **   与之不同的是处理行格式的方法不同

**Compact**处理行格式是 是将**溢出的数据**存入到溢出页中

**Dynamic**和**Compressed **   处理行格式是将数据**全部存储**到溢出页中  而数据只存储溢出页的地址。



### 10.5 行溢出

一个页的大小一般是16kb  也就是16*1024字节，但是varchar字节可存放65535个字节 所以就存在一个页放不下一条记录 这就叫行溢出。



### 10.6  区 、段、碎片区、表空间

**为什么需要区？**

读取的数据页可能不是连续的  所以就会发生**随机io**  增加数据缓冲的时间    所以我们体长**顺序io**    

![image-20220620221208541](http://inis.inis1719.cn/202206202212335.png)

**为什么需要段？**

区分叶子节点和非叶子节点。

 ![image-20220620221411906](http://inis.inis1719.cn/202206202214888.png)

**为什么需要碎片区？**

![image-20220620221831587](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620221831587.png)



区的分类：

![image-20220620222209355](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620222209355.png)



表空间

![image-20220620222308072](C:%5CUsers%5C%E4%B8%80%E5%8F%B7%E7%BA%BF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220620222308072.png)



