# 算法



## 1排序算法

### **1排序算法的各种概念**

#### **1.1排序算法常见分类如下**

1. 插入排序（直接插入排序，希尔排序）
2. 选择排序（简单选择排序，堆排序）
3. 交换排序（冒泡排序，快速排序）
4. 归并排序
5. 基数排序

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161542658.png)

#### **1.2时间复杂度和空间复杂度**

##### **1.2.1算法的时间复杂度**

事后统计的方法

这种方法可行,但是有两个问题:一是要想对设计的算法的运行性能进行评测,需要实际运行该程序;二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,**这**

**种方式,要在同一台计算机的相同状态下运行,才能比较那个算法速度更快**

2)事前估算的方法

通过分析某个算法的时间复杂度来判断哪个算法更优

##### **1.2.2时间频度**

**时间频度**:一个算法花费的**时间**与算法中语句的**执行次数**成正比例,哪个算法

1中语句执行次数多,它花费时间就多。一个算法中的语句执行次数称为语句频

度或时间频度。记为T(n)。（**其实就是算法中语句执行的次数**）

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161548101.png)

**1忽略常数项（比如2n和2n+20来说，随着n的增加 他们的曲线越来越相等，所以20可以忽略）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549998.png)

**2忽略低次方（其实就是时间频度中低次方的可以忽略不计 列入2n~3和2n~3+3n+1中的3n+1可以直接忽略不计）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549852.png)

**3忽略系数（立方不能忽略）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549146.png)

**时间复杂度之同数量极函数（即和T（n）相除的极限值不为0的常数的函数）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161550293.png)

#### **1.3时间复杂度常见类型**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551276.png)

##### **1.3.1常数阶 （无循环）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551187.png)

##### **1.3.2对数阶（一重循环  循环体数据\*2）**

![img](D:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CqqDBD1F84E1C986CF725E8AFDDB2DCE08F%5C37b347947e044c48b3efb9eda396924f%5Cclipboard.png)

##### **1.3.3线性阶（一重循环 里面数据无翻倍操作）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551289.png)

##### **1.3.4线性对数对数阶**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552854.png)

##### **1.3.5平方阶（两重循环）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552103.png)

#### **1.4算法的平均算法复杂度和最坏复杂度**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552791.png)

##### **1.4.1算法的空间复杂度**

**基本介绍**

- 类似于时间复杂度的讨论,一个算法的空间复杂度( Space Complexity)定义为该算法所耗费的存储空间,它也是问题规模n的函数。
- 空间复杂度 Space Complexity是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关,它随着n的增大而增大,当n较大时,将占用较多的存储单元,例如快速排序和归并排序算法就属于这种情况
- 在做算法分析时,主要讨论的是时间复杂度。从用户使用体验上看,更看重的程序执行的速度。一些缓存产品 redis, memcache和算法(基数排序)本质就是用空间换时间

### **2基础算法**

#### **2.1冒泡排序(O(N^2)**

##### **2.1.1简单概述：**

（从小到大顺序排序，有序排序）（这里的思想其实就是将相邻两个元素比较然后得到最大值放在数组最后 然后循环遍历）

##### **2.1.2基本介绍**

冒泡排序( Bubble Sorting)的基本思想是:通过对待排序序列从前向后(从下标较小的元素开始),依次比较相邻元素的值,若发现逆序则交换,使值较大的元素逐渐从前移向后部,就象水底下的气泡一样逐渐向上冒。

因为排序的过程中,各元素不断接近自己的位置,如果一趟比较下

来没有进行过交换,就说明序列有序,因此要在排序过程中设置

—个标志fag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优

化,可以在冒泡排序写好后,在进行

##### **2.1.3排序算法图解**

（就是由左向右比较相邻的元素然后一个数组的最大值，以此类推）

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161601735.png)

##### **2.1.4代码如下**

```
package a6排序算法;

import java.util.Arrays;
//排序算法思路
//将数组相邻的两个叔互相比较然后每次排序将最大的放在最后
public class Paixudemo1 {
    public static void main(String[] args) {
        //1实现数组
        int array[]= {-1,30,3,20,10};
        //代替节点
        int temp=0;
        //根据索引遍历
        for (int j = 0; j < array.length-1; j++) {
            //比较相邻数据大小
            for (int i = 0; i < array.length - 1-j; i++) {
                if (array[i]>array[i+1]){
                    temp=array[i];
                    array[i]=array[i+1];
                    array[i+1]=temp;
                }
            }
        }

        System.out.println(Arrays.toString(array));

    }
}

```

#### **2.2选择排序**

##### **2.2.1简单概述：**

**（自定义规则选择数据排序）（得到最小值然后将最小值和开头交换）**

##### **2.2.2图解如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161603462.png)

##### **2.2.3选择排序代码代码如下**

```
package 选择算法;

import java.util.Arrays;

public class Xuanze {
    public static void main(String[] args) {
        //定义数组
        int array[]={4,2,44,1};
            //排序几次
        for (int j = 0; j < array.length-1; j++) {
            int min=array[j];
            int minindex=j;
            //得到最小值和最小值的索引
            for (int i = 1+j; i < array.length ; i++) {
                if (array[i]<min){
                    min=array[i];
                    minindex=i;
                }

            }
            //将最小值和开头交换
            if (minindex!=j) {
                array[minindex] = array[j];
                array[j] = min;
            }
            System.out.println(j+"次"+Arrays.toString(array));
        }


    }
}

```

#### **2.3插入排序**

##### **2.3.1思路解析**

插入排序( insertion Sorting))的基本思想是:**个待排序的元素看成为个有序表和一个无序表,开始时有序表中只包含一个元素,无序表中包含有n-1个元素,排序过程中每次从无序表中取出第一个元素,把它的排序码依次与有序表元素的排序码进行比较,将它插入到有序表中的适当位置,使之成为新的有序表。**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161721379.png)

我再来详细的说一下插入排序 其实就是在一个数组中一开始默认第一个元素为有序表，后面的元素为无序表 流程如下

1比较待插入的元素与有序表最后一个元素比较大小 ，如果比他大的话直接插在有序表的最后也就是后移一位。如果比他小的话，比较的索引值--，在往前比较，然后比他大的又后移，直到前面的元素比他小时，加在该索引的后面。

##### **2.3.2代码如下**

```
package a8插入算法;

import java.util.Arrays;

//插入排序的思路是分为一个有序表和无序表
//一开始设定一个值放在有序表中，其他的都放在无序表中，然后取无需表中的元素与有序表中的元素比较  知道无需表中无元素为止
//每次插入的时候与有序表的最后一个元素进行比较 如果小于的话，比他大的元素后移，然后继续比较，知道前面没有比他大的值
public class Demo {

    public static void main(String[] args) {
        int array[]= {31,30,29,20,10};

        for (int i = 1; i < array.length; i++) {
            int insertval=array[i];
            int  inserindex=i-1;
            while(inserindex>=0   && insertval<array[inserindex]){
                array[inserindex+1]=array[inserindex];
                inserindex--;
            }
            array[inserindex+1]=insertval;
        }

        System.out.println("第一次排序的数组为"+ Arrays.toString(array));
    }
}


```

  					

#### **2.4希尔排序**

##### **2.4.1思路如下**

其实就是将数组的长度/2然后分组比较优化的方式万一数据最小的值在数组最后，插入排序就需要从最后一直移位多次，所有希尔排序实在插入排序的基础上进行优化。

这里关于希尔排序的分组规律是如何排序的？请看下面的解释。

链接解释  [理解希尔排序的排序过程_razorEdge的博客-CSDN博客_希尔排序的详细过程](https://blog.csdn.net/weixin_37818081/article/details/79202115)

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161721717.png)

依上图得：排序文件有10个记录，其关键字分别是27 38 65 97 76 13 27* 49 55 4. 增量序列的取值依次为：5，2，1。 第一趟排序时，d1=5，整个文件被分成5组：（27，13），（38，27*），（65，49），（97，55），（76，4）各组中的第一个记录都自成一个有序区，我们依次将各组的第2个记录直至**最后一个**。 第一趟排序结果：13 27* 49 55 4 27 38 65 97 76 第二趟排序时，d2=2 ，图如上。 第二趟排序结果：4 27* 13 27 38 55 49 65 97 76 最后一趟排序时，d3=1，即是对整个文件做直接插入排序，结果即为有序文件。

//这里的注意点是分完组后使用的是**插入排序 插入排序  插入排序 重要的事说三遍！**

##### **2.4.2希尔排序移位法代码实现**

```
package 希尔算法;

import java.util.Arrays;

public class Shellsuanfa {
    public static void main(String[] args) {
        int arrahy[] = {2, 3, 1, 5, 4, 7, 8, 9, 10, 0};
        int temp = 0;
        //重复操作

        //分组
        for (int gap = arrahy.length / 2; gap > 0; gap /= 2) {
            //第一轮辅助分组
            //后一组
            for (int i = gap; i < arrahy.length; i++) {
           
                System.out.println("当前的i为"+j+",与增量比较为"+(j+gap));
                //比较
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arrahy[j] > arrahy[j+gap]) {
                        temp = arrahy[j];
                        arrahy[j] = arrahy[j+gap];
                        arrahy[j+gap] = temp;
                    }
                }
            }

            System.out.println("第"+gap+"轮" + Arrays.toString(arrahy));
        }
    }
}

```

希尔排序这里又看不懂了 做一个详细的解释  ：

关于分组问题   分组后采用的是插入排序

第一轮的比较：

```
当前的i为0,与增量比较为5
当前的i为1,与增量比较为6
当前的i为2,与增量比较为7
当前的i为3,与增量比较为8
当前的i为4,与增量比较为9
第5轮[2, 3, 1, 5, 0, 7, 8, 9, 10, 4]
```

第二轮的比较：

```
当前的i为0,与增量比较为2
当前的i为1,与增量比较为3
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
当前的i为4,与增量比较为6
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为5,与增量比较为7
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
当前的i为6,与增量比较为8
当前的i为4,与增量比较为6
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为7,与增量比较为9
当前的i为5,与增量比较为7
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
第2轮[0, 3, 1, 4, 2, 5, 8, 7, 10, 9]

```

第三轮的比较：

```
当前的i为0,与增量比较为1
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为7,与增量比较为8
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为8,与增量比较为9
当前的i为7,与增量比较为8
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
第1轮[0, 1, 2, 3, 4, 5, 7, 8, 9, 10]

进程已结束,退出代码0

```



插入排序的理解就是看成一个无序表和一个有序表   

第一轮的排序 特别容易理解 就是两两一组  特别好理解

第二轮的排序  注意注意   排序规则不太易懂了  虽然理解成2组 但是代码执行的过程中却是交替执行的

列如   13   2 4    35    46  ····



![image-20220216172916480](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161729406.png)



##### **2.4.3希尔排序移位法**

```
//对交换式的希尔排序进行优化->移位法
public static void shellSort2(int[] arr) {
// 增量 gap, 并逐步的缩小增量
for (int gap = arr.length / 2; gap > 0; gap /= 2) {
// 从第 gap 个元素，逐个对其所在的组进行直接插入排序
for (int i = gap; i < arr.length; i++) {
int j = i;
int temp = arr[j];
if (arr[j] < arr[j - gap]) {
while (j - gap >= 0 && temp < arr[j - gap]) {
//移动
arr[j] = arr[j-gap];
j -= gap;
}
//当退出 while 后，就给 temp 找到插入的位置
arr[j] = temp;
}
}
}
}
}

```

#### **2.5快速排序**

##### **2.5.1思路如下：**

（对冒泡排序的改进：其实就是先选择1个数然后分割比较，左边的数比他小，右边的数比他大）

##### **2.5.2图解如下：**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161758687.png)

###### **2.5.3代码实现：（这里传入的值是数组的最大索引和最小索引）**

```
package 快速排序算法;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;

/*
基于冒泡排序的升级版
思路是定义一个数然后左边的比他小，右边的比他大
* */
public class Querykuai {
    public static void main(String[] args) {
        int[] ints = new int[8000000];
        int[] a = {1, -1, 3, 2, 0, 9};

        Date date = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String s = format.format(date);
        System.out.println(s
        );
        for (int i = 0; i < ints.length; i++) {
            ints[i]= (int) (Math.random()*8000000);

        }
        System.out.println(format.format(new Date()));
    }

    /*
     * @param */
    public static void queryint(int[] array, int left, int right) {
        int l = left;//左下标
        int r = right;//右下标
        int temp;
        int pivot = array[(l + r) / 2];//定义一个数区分
        //比他小的放在左边
        while (l < r) {
            while (array[l] < pivot) {
                l += 1;

            }
            //比他大的放在右边
            while (array[r] > pivot) {
                r -= 1;

            }
            //判断是否已经全部排序完
            if (l >= r) {
                break;
            }
            //交换
            temp = array[l];
            array[l] = array[r];
            array[r] = temp;

            if (array[l] == pivot) {
                r -= 1;

            }
            if (array[r] == pivot) {
                l += 1;
            }


        }
        if (l == r) {
            l += 1;
            r -= 1;

        }

        //递归
        if (r > left) {
            queryint(array, left, r);
        }
        if (right > l) {
            queryint(array, l, right);
        }


    }
}

```

#### **2.6归并排序**

##### **2.6.1思路分析：**

其实归并排序就是将数组分成多个数组然后多次排序最后整合到一个新的数组当中

归并排序( MERGE- SORT〕是利用**归并**的思想实现的排序方法,该算法采用经典的分治( divide and-conquer)策略(分治法将问题分( divide)成一些**小的问题**然后**递归求解**,而治( conquer)的阶段则将分的阶段得到的各答案"修补"在起,即分而治之

##### **2.6.2图解分析**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161759647.png)

##### **2.6.3归并代码实现**

```

package 归并排序;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;   

/*
* 其实就是将排序一直分组然后进行copy复制*/
public class Guibin {
    public static void main(String[] args) {
            int[] arr={1,-1,80,70,98,100};
        int[] temp=new int[arr.length/2];
            mergesort(arr,0,arr.length-1,temp);
        System.out.println("归并排序后"+ Arrays.toString(temp));
    }

    public static  void mergesort(int[]arr,int left,int right,int []temp){
  if (left<right){
      int mid=(left+right)/2;
      //左分治
      mergesort(arr,left,mid,temp);
      //右分治
      mergesort(arr,mid+1,right,temp);
      merge(arr,left,mid,right,temp);


  }
    }

    /**
     *
     * @param arr   需要排序的数组
     * @param left  左边的索引
     * @param right 右边的索引
     * @param mid   中间索引
     * @param temp  初始数组
     */
    public static  void merge(int[]arr,int left,int right,int mid,int []temp) {
        System.out.println("测试");
        int i = left;
        int j = mid + 1;
        int t = 0;//可变化 temp的可变化索引
        //1索引变化就停止
        //这里是分治
        while (i <= mid && j <= right) {
            if (arr[i]<=arr[j]){
                temp[t]=arr[i];
                t+=1;
                i+=1;
            }else {
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }
        }
            //说明还有i 全部填充
            while (i <= mid) {
                temp[t]=arr[i];
                t+=1;
                i+=1;
            }
            //说明还有i 全部填充
            while (j <= right) {
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }
            //在在这里就是将分组的数组认真排序然后放入数组当中
            t=0;
            int tempindex=left;
            while (tempindex<=right){
                arr[tempindex]=temp[t];
                t+=1;
                tempindex+=1;
            }


    }
}


```

#### **2.7基数排序（桶排序）**

##### **2.7.1思想如下：**

将所有待比较数值统一为同样的数位长度,数位较短的数前面补零。然后,从最低位开始,依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。这样说明,比较难理解,下面我们看一个图文解释,理解基数排序的步骤

//基数排序的思路其实就是先准备0-9这10个桶，然后根据数组元素的位数进行放置，另外排序的次数取决于数组中最大元素的位数，列如4005 ，这个数组最大值元素的位数为4.所以需要排序4次

//基数排序的缺点就是数据不能够为负数  原因是因为基数排序在使用数组存放在那个桶的时候需要得到余数 ，而基数排序的桶都是正数。

排序图列说明

#### **2.8堆排序（使用树结构）**

##### **2.8.1思想如下**

1. 将待排序序列构造成一个大顶堆，此时,整个序列的最大值就是堆顶的根节点。
2. 将其与末尾元素进行交换,此时末尾就为最大值然后将剩余n-1个元素重新构造成一个堆,这样会得到n个元素的次小值。
3. 如此反复执行,便能得到一个有序序列了。
4. 可以看到在构建大顶堆的过程中,元素的个数逐渐减少,最后就得到一个有序序列了

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161800084.png)

##### **2.8.2相关名词**

大顶堆： 父节点大于左右子节点 左右子节点没有要求

小顶堆： 父节点小于左右子节点 左右子节点没有要求

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161800588.png)

根据我的理解就是先把大顶堆构建出来  ，然后在逐渐缩小数组的长度，然后交换进行遍历 ， 这里需要注意的点是 大顶堆的排序次数为数组的长度/2-1

**2.8.3代码如下**

```
package a16堆排序;

import java.util.Arrays;

public class Duipaix {
    public static void main(String[] args) {
        int [] array={4,6,8,5,9};
zuizhong(array);
        System.out.println(Arrays.toString(array));

    }
    public static  void  zuizhong(int [] array){
        //构建大顶堆的次数
        for (int i = array.length / 2 - 1; i >= 0; i--) {
            duipaixu(array,i, array.length);
        }
        //减少排序元素  多次排序
        for (int i = array.length - 1; i >= 0; i--) {
            //交换
            int temp=array[i];
            array[i]=array[0];
            array[0]=temp;
            duipaixu(array,0,i);
        }

    }
    //构建大顶堆
    public static void  duipaixu(int [] array,int i, int length){

            int temp =array[i];
            for (int k=2*i+1; k<length; k=k*2+1) {
                if (k+1<length && array[k+1]>array[k]) {
                    k++;

                }
                if (array[k]>array[i]){
                    array[i]=array[k];
                    i=k;
                }else {
                    break;
                }
                array[k]=temp;
        }


    }
}

```



## 2查找算法

### **1 线性查找**

#### **1.1代码如下**

也就是我们平常常用的查找方式）

```
package a13查找算法.b1线性查找;

public class Xianfind {


    public static void main(String[] args) {
        int[] arr={66,564,957,72,91,108};
        find(arr,957);
    }
    public  static int  find(int[] arr ,int value){
        for (int i = 0; i < arr.length; i++) {
             if (arr[i]==value){
                 System.out.println("当前数据已找到，下标为"+i);
                 return  i;
             }
        }
        return  -1;
    }
}

```



### **2 二分查找**

#### **2.1思路分析**

**（前提是数组必须是有序的）**

1. 首先确定该数组的中间的下标mid=(left+right)/2
2. 然后让需要查找的数 findva|和armd]比较
3.  findval> arr[mid],说明你要查找的数在md的右边,因此需要递归的向右查找
4.  findval< arr[mid],说明你要查找的数在md的左边,因此需要递归的向左查找
5.  findVal= araMid]说明找到,就返回

**2.2代码如下：**

```
package a13查找算法.b2二分查找;

public class Erfenfind {


    public static void main(String[] args) {
        int[] arr={66,564,957,72,91,108};
        System.out.println(find(arr, 8989, 0, arr.length - 1));
    }
    public  static int  find(int[] arr ,int value,int left,int right) {
        int mid = (left + right) / 2;
        if (left > right) {
            return -1;
        }
        //判断大于条件
        if (value > arr[mid]) {
         return      find(arr, value, mid + 1, right);

        } else if (value < arr[mid]) {
           return   find(arr, value, left, mid - 1);
        } else  {
            return mid;
        }

    }

}

```

### **3 插值查找算法**

#### **3.1思路如下**

（**类似于二分查找，但是与之不同的是二分查找查找的时候是根据中间值，所以会运行多次，而插值查找则是就是mid值快速找到数据，也就是说插值查找比二分查找查询的次数更少）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181343092.png)

#### **2.2代码如下**

```
package a13查找算法.b3插值查找;

import java.util.Arrays;

public class Chazhifind {


    public static void main(String[] args) {
        int[] arr=new int [100];
        for (int i = 0; i < arr.length; i++) {
              arr[i]=i+1;
        }
        System.out.println(Arrays.toString(arr));

        System.out.println(find(arr, 50, 0, arr.length - 1));
    }
    /*
    *
    *
    * */
    public  static int  find(int[] arr ,int value,int left,int right) {
        int mid =left+(right-left)*(value-arr[left])/(arr[right]-arr[left]);
        //没找到结束循环的条件
        if (left > right || value< arr[0] || value>arr[arr.length-1]){
            return -1;
        }
        //判断大于条件
        if (value > arr[mid]) {
         return      find(arr, value, mid + 1, right);

        } else if (value < arr[mid]) {
           return   find(arr, value, left, mid - 1);
        } else  {
            return mid;
        }

    }

}

```

### **4 斐波那契（黄金分割法）查找算法**

**（计算出黄金分割率 然后进行查找）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181345496.png)







## 3常用的十大算法

### **1二分查找算法（有序数组）**

#### **1.1代码如下**

```
package a4常用十大算法.d1二分查找算法;

/**
 * @author zhouhelong
 * @creat 2021-06-16 15:40
 * @description: 二分查找算法非递归
 */
public class D1erfen {
    public static void main(String[] args) {
        int[] array = {1, 3, 8, 11, 67, 100};

        System.out.println(getnums(array, 8, 0, array.length - 1));
        System.out.println("非递归");
        System.out.println(getindex(array, 100));
    }

    /**
     * @return int
     * @Author zhouhelong
     * @Description: 递归实现二分查找
     * @Date 2021/6/16
     * @params [array, n, end, last]
     **/
    public static int getnums(int[] array, int n, int end, int last) {

        int mid = (end + last) / 2;
        while (n == array[mid]) {
            return mid;
        }
        if (n < array[mid]) {
            return getnums(array, n, 0, mid - 1);
        } else {
            return getnums(array, n, mid + 1, array.length);
        }

    }

    /**
     * @return int
     * @Author zhouhelong
     * @Description:
     * @Date 16:15 2021/6/16
     * @params [array, n]
     **/
    public static int getindex(int[] array, int n) {
        int left = 0;
        int right = array.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (n == array[mid]) {
                return mid;
            } else if (n > array[mid]) {
                left = mid + 1;
            } else if (n < array[mid]) {
                right = mid - 1;
            }
        }
        return -1;
    }
}

```

### **2分治算法**

#### **2.1个人理解**

**其实就是将大问题分成小的问题逐步解决**

#### **2.2分治算法介绍**

分治法是一种很重要的算法。字面上的解释是“分而治之”,就是把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…直到最后子问题可以简单的直接求解,原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础,如排序算法(快速排序,归并排序),傅立叶变换(快速傅立叶变换)

分治算法可以求解的一些经典问题

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- 合并排序
- 快速排序
- 线性时间选择
- 最接近点对问题
- 循环赛日程表
- 汉诺塔

#### **2.3实现步骤**

分治法在每一层递归上都有三个步骤

1)分解:将原向题分解为若干个规模较小,相互独立,与原问题形式相同的子问题

2)解决:若子问题规模较小而容易被解决则直接解,否则递归地解各个子问题

3)合并:将各个子问题的解合并为原问题的解

#### **2.4韩罗塔代码如下**

```
package a4常用十大算法.d2分治算法;

/**
 * @author zhouhelong
 * @creat 2021-06-16 16:33
 * @description: 韩罗塔游戏代码解释
 */
public class D2fenzhi {
    public static void main(String[] args) {

        Hanluo('a', 'b', 'c', 5);


    }


    /**
     * @return void
     * @Author zhouhelong
     * @Description:
     * @Date 16:34 2021/6/16
     * @params [a, 柱子a b 柱子b, c 柱子c, nums  盘数]
     **/
    public static void Hanluo(char a, char b, char c, int nums) {
        if (nums == 1) {
            System.out.println("第一个盘子从" + a + "移动到" + c);
        } else if (nums >= 2) {
            //这里的逻辑思路是无论有多少个盘我们都只看作2个盘  
            //上面的盘需要移动到b盘 然后在下面的盘移动到c盘  最后将b盘的全部移动在c盘
            Hanluo(a, c, b, nums - 1);
            System.out.println("第" + nums + "个从" + a + "移动到" + c + "盘");
            //移动到c盘
            Hanluo(b, a, c, nums - 1);


        }


    }
}

```

### **3动态规划算法**

####  **3.1介绍**

（其实也是将大问题分解成小问题  与分治算法不同的是他分解的每个问题都不是独立的 ）

1)动态规划( Dynamic Programming)算法的核心思想是:将大问题划分为小问题进行解决,从而一步步获取最优解的处理算法

2)动态规划算法与分治算法类似,其基本思想也是将待求解问题分解成若干个子问题,先求解子问题,然后从这些子问题的解得到原问题的解

3)与分治法不同的是,适合于用动态规划求解的问题,经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上,进行进一步的求解)

4)动态规划可以通过填表的方式来逐步推进,得到最优解

#### **3.2实际案例操作**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181350685.png)

##### **3.2.1思路如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181350450.png)

### **4暴力算法**

##### **4.1场景应用**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181351273.png)

##### **4.2代码如下**

```
package a4常用十大算法.d4暴力匹配算法;

/**
 * @author zhouhelong
 * @creat 2021-06-16 21:22
 * @description:
 */
public class D4暴力 {
    public static void main(String[] args) {
        String a = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String b = "尚硅谷你尚硅你";
        System.out.println(isblack(a, b));
    }

    public static boolean isblack(String a, String b) {
        char[] A = a.toCharArray();
        char[] B = b.toCharArray();
        int i = 0;
        int j = 0;
        int nums = 0;
        while (i < A.length && j < B.length) {
            if (A[i] == B[j]) {
                i++;
                j++;
                nums++;
            } else {
                i = i - j + 1;
                j = 0;
                nums = 0;
            }
            while (nums == B.length) {
                return true;
            }
        }

        return false;

    }
}

```

### **5   KMP算法**

#### **5.1KMP介绍**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181351116.png)

#### **5.2部分匹配表**

是将一个字符串从0开始知道他的最大长度得到的元素的前缀和后缀之间的交集的个数就是对应字符串的部分匹配值。

![img](D:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CqqDBD1F84E1C986CF725E8AFDDB2DCE08F%5Ca2abd8b2d2f44e319f18bbd75892f278%5Cclipboard.png)

**代码如下**

```
package a4常用十大算法.d5KMP;

import java.util.Arrays;

/**
 * @author zhouhelong
 * @creat 2021-06-25 14:36
 * @description:
 */
public class Kmpclass {
    public static void main(String[] args) {
        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String str2 = "尚硅谷你尚硅你~";

        System.out.println(Arrays.toString(gettable("AAAA")));


    }

    public static int Kmpsearch(String s1, String s2, int[] next) {
        for (int i = 0, j = 0; i < s1.length(); i++) {
            while (j > 0 && s1.charAt(i) != s2.charAt(j)) {
                j = next[j - 1];
            }

            if (s1.charAt(i) == s2.charAt(j)) {
                j++;
            }
            if (j == s2.length()) {
                return i - j + 1;
            }


        }
        return  -1;
    }

    public static int[] gettable(String str) {

        int[] chars = new int[str.length()];
        //第一位的部分匹配值一定为0；
        chars[0] = 0;//


        //i为字符串的索引，j为匹配值
        for (int i = 1, j = 0; i < str.length(); i++) {
            //kmp算法的核心
            while (j > 0 && str.charAt(i) != str.charAt(j)) {
                j = chars[j - 1];
            }
            //这种情况是“AA”
            if (str.charAt(i) == str.charAt(j)) {
                j++;
            }
            chars[i] = j;
        }
        return chars;
    }
}

```

### **6贪心算法**

#### **6.1介绍： 每一步都去寻找最优解**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181354660.png)

#### **6.2问题如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181355720.png)

##### **6.2.1思路分析：（就是找到最大覆盖值然后使用）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181355806.png)

##### **6.2.2代码如下**

```
package a4常用十大算法.d6贪心算法;

import java.util.*;

/**
 * @author zhouhelong
 * @creat 2021-06-26 19:51
 * @description:
 */
public class Tanxin {

    public static void main(String[] args) {
        //创建广播电台,放入到 Map
        HashMap<String, HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
//将各个电台放入到 broadcasts
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");
//加入到 map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);
//allAreas 存放所有的地区
        HashSet<String> allAreas = new HashSet<String>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");
//创建 ArrayList, 存放选择的电台集合
        ArrayList<String> selects = new ArrayList<String>();
//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区


        HashSet<String> tempSet = new HashSet<String>();
//定义给 maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的 key
//如果 maxKey 不为 null , 则会加入到 selects
        String maxKey = null;
        while (allAreas.size() != 0) { // 如果 allAreas 不为 0, 则表示还没有覆盖到所有的地区
//每进行一次 while,需要
            maxKey = null;
//遍历 broadcasts, 取出对应 key
            for (String key : broadcasts.keySet()) {
//每进行一次 for
                tempSet.clear();
//当前这个 key 能够覆盖的地区
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
//求出 tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet
                tempSet.retainAll(allAreas);
//如果当前这个集合包含的未覆盖地区的数量，比 maxKey 指向的集合地区还多
//就需要重置 maxKey
// tempSet.size() >broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的
                if (tempSet.size() > 0 &&
                        (maxKey == null || tempSet.size() > broadcasts.get(maxKey).size())) {
                    maxKey = key;
                }

            }
//maxKey != null, 就应该将 maxKey 加入 selects
            if (maxKey != null) {
                selects.add(maxKey);
//将 maxKey 指向的广播电台覆盖的地区，从 allAreas 去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
        System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]
    }
}

        

```

### **7普利姆算法**

#### **7.1场景如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181359223.png)

#### **7.2最小生成树**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181359886.png)

#### **7.3算法思路**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181359911.png)

##### **7.3.1代码如下**

```
package a4常用十大算法.d8普利姆算法;

import java.util.Arrays;

/**
 * @author zhouhelong
 * @creat 2021-06-26 20:55
 * @description:
 */
public class Pulimu {
    public static void main(String[] args) {
        //测试看看图是否创建 ok
        char[] data = new char[]{'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int verxs = data.length;
//邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通
        int[][] weight = new int[][]{
                {10000, 5, 7, 10000, 10000, 10000, 2}, {5, 10000, 10000, 9, 10000, 10000, 3}, {7, 10000, 10000, 10000, 8, 10000, 10000}, {10000, 9, 10000, 10000, 10000, 4, 10000}, {10000, 10000, 8, 10000, 10000, 5, 4}, {10000, 10000, 10000, 4, 5, 10000, 6}, {2, 3, 10000, 10000, 4, 6, 10000},};
//创建 MGraph 对象
        MGraph graph = new MGraph(verxs);
//创建一个 MinTree 对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph, verxs, data, weight);
//输出
        minTree.showGraph(graph);
//测试普利姆算法
        minTree.prim(graph, 1);//尚硅谷 Java 数据结构和算法

    }
}

//创建最小生成树->村庄的图
class MinTree {
//创建图的邻接矩阵

    /**
     * @param graph  图对象
     * @param verxs  图对应的顶点个数
     * @param data   图的各个顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) {
        int i, j;
        for (i = 0; i < verxs; i++) {//顶点
            graph.data[i] = data[i];
            for (j = 0; j < verxs; j++) {
                graph.weight[i][j] = weight[i][j];
            }
        }
    }

    //显示图的邻接矩阵
    public void showGraph(MGraph graph) {

        for (int[] link : graph.weight) {
            System.out.println(Arrays.toString(link));
        }
    }
//编写 prim 算法，得到最小生成树

    /**
     * @param graph 图
     * @param v     表示从图的第几个顶点开始生成'A'->0 'B'->1...
     */
    public void prim(MGraph graph, int v) {
//visited[] 标记结点(顶点)是否被访问过
        int visited[] = new int[graph.verxs];
//visited[] 默认元素的值都是 0, 表示没有访问过
// for(int i =0; i <graph.verxs; i++) {
// visited[i] = 0;
// }
//把当前这个结点标记为已访问
        visited[v] = 1;
//h1 和 h2 记录两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        int minWeight = 10000; //将 minWeight 初始成一个大数，后面在遍历过程中，会被替换
        for (int k = 1; k < graph.verxs; k++) {//因为有 graph.verxs 顶点，普利姆算法结束后，有 graph.verxs-1 边尚硅谷 Java 数据结构和算法
//这个是确定每一次生成的子图 ，和哪个结点的距离最近
            for (int i = 0; i < graph.verxs; i++) {// i 结点表示被访问过的结点
                for (int j = 0; j < graph.verxs; j++) {//j 结点表示还没有访问过的结点
                    if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j] < minWeight) {
//替换 minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
//找到一条边是最小
            System.out.println("边<" + graph.data[h1] + "," + graph.data[h2] + "> 权值:" + minWeight);
//将当前这个结点标记为已经访问
            visited[h2] = 1;
//minWeight 重新设置为最大值 10000
            minWeight = 10000;
        }
    }
}

class MGraph {
    int verxs; //表示图的节点个数
    char[] data;//存放结点数据尚硅谷 Java 数据结构和算法

    int[][] weight; //存放边，就是我们的邻接矩阵

    public MGraph(int verxs) {
        this.verxs = verxs;
        data = new char[verxs];
        weight = new int[verxs][verxs];
    }
}

```

### **8克鲁斯卡算法**

（其实还是使用最小树得到最小权值求解）

#### **8.1应用场景**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181400162.png)

#### **8.2介绍如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181400794.png)

#### **8.3图解思路如下**

**根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问 题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。 然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。**

##### **8.3.1代码如下**

```

package a4常用十大算法.d9krusal算法;

import java.util.Arrays;

public class KruskalCase {
    private int edgeNum; //边的个数
    private char[] vertexs; //顶点数组
    private int[][] matrix; //邻接矩阵
    //使用 INF 表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
//克鲁斯卡尔算法的邻接矩阵
        int matrix[][] = {
/*A*//*B*//*C*//*D*//*E*//*F*//*G*/
/*A*/ {0, 12, INF, INF, INF, 16, 14}, /*B*/ {12, 0, 10, INF, INF, 7, INF}, /*C*/ {INF, 10, 0, 3, 5, 6, INF}, /*D*/ {INF, INF, 3, 0, 4, INF, INF},

/*E*/ {INF, INF, 5, 4, 0, 2, 8}, /*F*/ {16, 7, 6, INF, 2, 0, 9}, /*G*/ {14, INF, INF, INF, 8, 9, 0}};
//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树. //创建 KruskalCase 对象实例
        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
//输出构建的
        kruskalCase.print();
        kruskalCase.kruskal();
    }

    //构造器
    public KruskalCase(char[] vertexs, int[][] matrix) {
//初始化顶点数和边的个数
        int vlen = vertexs.length;
//初始化顶点, 复制拷贝的方式
        this.vertexs = new char[vlen];
        for (int i = 0; i < vertexs.length; i++) {
            this.vertexs[i] = vertexs[i];
        }
//初始化边, 使用的是复制拷贝的方式
        this.matrix = new int[vlen][vlen];

        for (int i = 0; i < vlen; i++) {
            for (int j = 0; j < vlen; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
//统计边的条数
        for (int i = 0; i < vlen; i++) {
            for (int j = i + 1; j < vlen; j++) {
                if (this.matrix[i][j] != INF) {
                    edgeNum++;
                }
            }
        }
    }

    public void kruskal() {
        int index = 0; //表示最后结果数组的索引
        int[] ends = new int[edgeNum]; //用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点
//创建结果数组, 保存最后的最小生成树
        EData[] rets = new EData[edgeNum];
//获取图中 所有的边的集合 ， 一共有 12 边
        EData[] edges = getEdges();
        System.out.println("图的边的集合=" + Arrays.toString(edges) + " 共" + edges.length); //12
//按照边的权值大小进行排序(从小到大)尚硅谷 Java 数据结构和算法

        sortEdges(edges);
//遍历 edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入
        for (int i = 0; i < edgeNum; i++) {
//获取到第 i 条边的第一个顶点(起点)
            int p1 = getPosition(edges[i].start); //p1=4
//获取到第 i 条边的第 2 个顶点
            int p2 = getPosition(edges[i].end); //p2 = 5
//获取 p1 这个顶点在已有最小生成树中的终点
            int m = getEnd(ends, p1); //m = 4
//获取 p2 这个顶点在已有最小生成树中的终点
            int n = getEnd(ends, p2); // n = 5
//是否构成回路
            if (m != n) { //没有构成回路
                ends[m] = n; // 设置 m 在"已有最小生成树"中的终点 <E,F> [0,0,0,0,5,0,0,0,0,0,0,0]
                rets[index++] = edges[i]; //有一条边加入到 rets 数组
            }
        }
//<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
//统计并打印 "最小生成树", 输出 rets
        System.out.println("最小生成树为");
        for (int i = 0; i < index; i++) {
            System.out.println(rets[i]);
        }
    }

    //打印邻接矩阵
    public void print() {
        System.out.println("邻接矩阵为: \n");
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = 0; j < vertexs.length; j++) {
                System.out.printf("%12d", matrix[i][j]);
            }
            System.out.println();//换行
        }
    }

    /**
     * 功能：对边进行排序处理, 冒泡排序
     *
     * @param edges 边的集合
     */
    private void sortEdges(EData[] edges) {
        for (int i = 0; i < edges.length - 1; i++) {
            for (int j = 0; j < edges.length - 1 - i; j++) {
                if (edges[j].weight > edges[j + 1].weight) {//交换
                    EData tmp = edges[j];
                    edges[j] = edges[j + 1];
                    edges[j + 1] = tmp;
                }
            }
        }
    }

    /**
     * @param ch 顶点的值，比如'A','B' * @return 返回 ch 顶点对应的下标，如果找不到，返回-1
     */
    private int getPosition(char ch) {
        for (int i = 0; i < vertexs.length; i++) {
            if (vertexs[i] == ch) {//找到
                return i;
            }
        }
//找不到,返回-1
        return -1;
    }

    /**
     * 功能: 获取图中边，放到 EData[] 数组中，后面我们需要遍历该数组
     * 是通过 matrix 邻接矩阵来获取
     * EData[] 形式 [['A','B', 12], ['B','F',7], .....]
     *
     * @return
     */
    private EData[] getEdges() {
        int index = 0;
        EData[] edges = new EData[edgeNum];
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = i + 1; j < vertexs.length; j++) {
                if (matrix[i][j] != INF) {
                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
                }
            }
        }
        return edges;
    }

    /**
     * 功能: 获取下标为 i 的顶点的终点(), 用于后面判断两个顶点的终点是否相同
     *
     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成
     * @param i    : 表示传入的顶点对应的下标
     * @return 返回的就是 下标为 i 的这个顶点对应的终点的下标, 一会回头还有来理解
     */
    private int getEnd(int[] ends, int i) { // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]
        while (ends[i] != 0) {
            i = ends[i];
        }
        return i;
    }
}

//创建一个类 EData ，它的对象实例就表示一条边尚硅谷 Java 数据结构和算法
class EData {
    char start; //边的一个点
    char end; //边的另外一个点
    int weight; //边的权值

    //构造器
    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //重写 toString, 便于输出边信息
    @Override
    public String toString() {
        return "EData [<" + start + ", " + end + ">= " + weight + "]";
    }
}

```

### **9迪杰斯特拉算法**

#### **9.1应用场景-最短路径问题**

战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到A, B, C , D, E, F 六个村庄，各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里问：如何计算出 G 村庄到 其它各个村庄的最短距离?如果从其它点出发到各个点的最短距离又是多少?

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181400901.png)

#### **9.2算法介绍**

迪杰斯特拉(Dijkstra)算法是**典型最短路径算法**，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(**广度优先搜索思想**)，直到扩展到终点为止。

#### **9.3迪杰斯特拉(Dijkstra)算法过程**

1. 设置出发顶点为 v，顶点集合 V{v1,v2,vi...}，v 到 V 中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di)
2. 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 到 vi 即为最短路径
3. 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的
4. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

#### **9.4算法最佳应用-最短路径**

战争时期，胜利乡有7个村庄(A,B,C,D,E,F,G)，现在有六个邮差，从G点出发，需要分别把邮件分别送到A,B,C,D,E,F六个村庄各个村庄的距离用边线表示(权)，比如A–B距离5公里 问：如何计算出G村庄到其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? 使用图解的方式分析了迪杰斯特拉(Dijkstra)算法思路

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181401369.png)

#### **9.5代码如下**

```
package a4常用十大算法.迪杰斯特拉;
import java.util.Arrays;
public class DijkstraAlgorithm {
public static void main(String[] args) {
char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
//邻接矩阵
int[][] matrix = new int[vertex.length][vertex.length];
final int N = 65535;// 表示不可以连接

matrix[0]=new int[]{N,5,7,N,N,N,2};
matrix[1]=new int[]{5,N,N,9,N,N,3};
matrix[2]=new int[]{7,N,N,N,8,N,N};
matrix[3]=new int[]{N,9,N,N,N,4,N};
matrix[4]=new int[]{N,N,8,N,N,5,4};
matrix[5]=new int[]{N,N,N,4,5,N,6};
matrix[6]=new int[]{2,3,N,N,4,6,N};
//创建 Graph 对象
Graph graph = new Graph(vertex, matrix);
//测试, 看看图的邻接矩阵是否 ok
graph.showGraph();
//测试迪杰斯特拉算法
graph.dsj(2);//C
graph.showDijkstra();
}
}
class Graph {
private char[] vertex; //顶点数组
private int[][] matrix; //邻接矩阵
private VisitedVertex vv; //已经访问的顶点的集合
// 构造器

public Graph(char[] vertex, int[][] matrix) {
this.vertex = vertex;
this.matrix = matrix;
}
//显示结果
public void showDijkstra() {
vv.show();
}
// 显示图
public void showGraph() {
for (int[] link : matrix) {
System.out.println(Arrays.toString(link));
}
}
//迪杰斯特拉算法实现
/**
*
* @param index 表示出发顶点对应的下标
*/
public void dsj(int index) {
vv = new VisitedVertex(vertex.length, index);
update(index);//更新 index 顶点到周围顶点的距离和前驱顶点
for(int j = 1; j <vertex.length; j++) {
index = vv.updateArr();// 选择并返回新的访问顶点
update(index); // 更新 index 顶点到周围顶点的距离和前驱顶点
}
}
//更新 index 下标顶点到周围顶点的距离和周围顶点的前驱顶点,
private void update(int index) {
int len = 0;
//根据遍历我们的邻接矩阵的 matrix[index]行
for(int j = 0; j < matrix[index].length; j++) {
// len 含义是 : 出发顶点到 index 顶点的距离 + 从 index 顶点到 j 顶点的距离的和
len = vv.getDis(index) + matrix[index][j];
// 如果 j 顶点没有被访问过，并且 len 小于出发顶点到 j 顶点的距离，就需要更新
if(!vv.in(j) && len < vv.getDis(j)) {
vv.updatePre(j, index); //更新 j 顶点的前驱为 index 顶点
vv.updateDis(j, len); //更新出发顶点到 j 顶点的距离
}
}
}
}
// 已访问顶点集合
class VisitedVertex {
// 记录各个顶点是否访问过 1 表示访问过,0 未访问,会动态更新
public int[] already_arr;
// 每个下标对应的值为前一个顶点下标, 会动态更新
public int[] pre_visited;
// 记录出发顶点到其他所有顶点的距离,比如 G 为出发顶点，就会记录 G 到其它顶点的距离，会动态更新，求的最短距离就会存放到 dis
public int[] dis;
//构造器
/**
*
* @param length :表示顶点的个数
* @param index: 出发顶点对应的下标, 比如 G 顶点，下标就是 6
*/
public VisitedVertex(int length, int index) {
this.already_arr = new int[length];
this.pre_visited = new int[length];
this.dis = new int[length];
//初始化 dis 数组
Arrays.fill(dis, 65535);
this.already_arr[index] = 1; //设置出发顶点被访问过
this.dis[index] = 0;//设置出发顶点的访问距离为 0
}
/**
* 功能: 判断 index 顶点是否被访问过
* @param index
* @return 如果访问过，就返回 true, 否则访问 false
*/
public boolean in(int index) {
return already_arr[index] == 1;
}
/**
* 功能: 更新出发顶点到 index 顶点的距离
* @param index
* @param len
*/
public void updateDis(int index, int len) {
dis[index] = len;
}
/**
* 功能: 更新 pre 这个顶点的前驱顶点为 index 顶点
* @param pre
* @param index
*/
public void updatePre(int pre, int index) {
pre_visited[pre] = index;
}
/**
* 功能:返回出发顶点到 index 顶点的距离
* @param index
*/
public int getDis(int index) {
return dis[index];
}
/**
* 继续选择并返回新的访问顶点， 比如这里的 G 完后，就是 A 点作为新的访问顶点(注意不是出发顶点)
* @return
*/
public int updateArr() {
int min = 65535, index = 0;
for(int i = 0; i < already_arr.length; i++) {
if(already_arr[i] == 0 && dis[i] < min ) {
min = dis[i];
index = i;
}
}
//更新 index 顶点被访问过
already_arr[index] = 1;
return index;
}
//显示最后的结果
//即将三个数组的情况输出
public void show() {
System.out.println("==========================");
//输出 already_arr
for(int i : already_arr) {
System.out.print(i + " ");
}
System.out.println();
//输出 pre_visited
for(int i : pre_visited) {
System.out.print(i + " ");
}
System.out.println();
//输出 dis
for(int i : dis) {
System.out.print(i + " ");
}
System.out.println();
//为了好看最后的最短距离，我们处理
char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
int count = 0;
for (int i : dis) {
if (i != 65535) {
System.out.print(vertex[count] + "("+i+") ");
} else {
System.out.println("N ");
}
count++;

}
System.out.println();
}
}

```

### **10弗洛伊德算法**

#### **10.1弗洛伊德(Floyd)算法介绍**

- 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名
- 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径
- 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
- 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。

#### **10.2 弗洛伊德(Floyd)算法图解分析**

1. 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径
2. 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得
3.  弗洛伊德(Floyd)算法图解分析-举例说明

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181401016.png)

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181401048.png)

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181401898.png)

#### **10.3弗洛伊德(Floyd)算法最佳应用-最短路径**

1. 胜利乡有 7 个村庄(A, B, C, D, E, F, G)
2. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里
3. 问：如何计算出各村庄到 其它各村庄的最短距离?

#### **10.4代码实现**

```
package a4常用十大算法.d11弗洛伊德算法;


import java.util.Arrays;
public class FloydAlgorithm {
public static void main(String[] args) {
// 测试看看图是否创建成功
char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
//创建邻接矩阵
int[][] matrix = new int[vertex.length][vertex.length];
final int N = 65535;
matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };
//创建 Graph 对象
Graph graph = new Graph(vertex.length, matrix, vertex);
//调用弗洛伊德算法
graph.floyd();
graph.show();
}
}

// 创建图
class Graph {
private char[] vertex; // 存放顶点的数组
private int[][] dis; //保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组
private int[][] pre;//保存到达目标顶点的前驱顶点
// 构造器
/**
*
* @param length
*
大小
* @param matrix
*
邻接矩阵
* @param vertex
*
顶点数组
*/
public Graph(int length, int[][] matrix, char[] vertex) {
this.vertex = vertex;
this.dis = matrix;
this.pre = new int[length][length];
// 对 pre 数组初始化, 注意存放的是前驱顶点的下标
for (int i = 0; i < length; i++) {
Arrays.fill(pre[i], i);
}
}

// 显示 pre 数组和 dis 数组
public void show() {
//为了显示便于阅读，我们优化一下输出
char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
for (int k = 0; k < dis.length; k++) {
// 先将 pre 数组输出的一行
for (int i = 0; i < dis.length; i++) {
System.out.print(vertex[pre[k][i]] + " ");
}
System.out.println();
// 输出 dis 数组的一行数据
for (int i = 0; i < dis.length; i++) {
System.out.print("("+vertex[k]+"到"+vertex[i]+"的最短路径是" + dis[k][i] + ") ");
}
System.out.println();
System.out.println();
}
}
//弗洛伊德算法, 比较容易理解，而且容易实现
public void floyd() {
int len = 0; //变量保存距离
//对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G]
for(int k = 0; k < dis.length; k++) { //
//从 i 顶点开始出发 [A, B, C, D, E, F, G]
for(int i = 0; i < dis.length; i++) {
//到达 j 顶点 // [A, B, C, D, E, F, G]
for(int j = 0; j < dis.length; j++) {
len = dis[i][k] + dis[k][j];// => 求出从 i 顶点出发，经过 k 中间顶点，到达 j 顶点距离
if(len < dis[i][j]) {//如果 len 小于 dis[i][j]
dis[i][j] = len;//更新距离
pre[i][j] = pre[k][j];//更新前驱顶点
}
}
}
}
}
}

```

### **11马踏棋盘算法**

#### **11.1马踏棋盘算法介绍**

- 马踏棋盘算法也被称为骑士周游问题
- 将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格
- 游戏演示: http://www.4399.com/flash/146267_2.html

#### **11.2 马踏棋盘游戏代码实现**

1. 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。
2. 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181402973.png)

##### **11.2.1代码实现**

```
package a4常用十大算法.d12马踏棋盘算法;
import java.awt.Point;
import java.util.ArrayList;
import java.util.Comparator;
public class HorseChessboard {
private static int X; //棋盘的列数
private static int Y; //棋盘的行数
//创建一个数组，标记棋盘的各个位置是否被访问过
private static boolean visited[];
//使用一个属性，标记是否棋盘的所有位置都被访问
private static boolean finished; // 如果为 true,表示成功
public static void main(String[] args) {
System.out.println("骑士周游算法，开始运行~~");
//测试骑士周游算法是否正确
X = 8;
Y = 8;
int row = 1; //马儿初始位置的行，从 1 开始编号
int column = 1; //马儿初始位置的列，从 1 开始编号
//创建棋盘
int[][] chessboard = new int[X][Y];
visited = new boolean[X * Y];//初始值都是 false
//测试一下耗时
long start = System.currentTimeMillis();
traversalChessboard(chessboard, row - 1, column - 1, 1);
long end = System.currentTimeMillis();
System.out.println("共耗时: " + (end - start) + " 毫秒");
//输出棋盘的最后情况
for(int[] rows : chessboard) {
for(int step: rows) {
System.out.print(step + "\t");
}
System.out.println();
}
}
/**
* 完成骑士周游问题的算法
* @param chessboard 棋盘
* @param row 马儿当前的位置的行 从 0 开始
* @param column 马儿当前的位置的列 从 0 开始
* @param step 是第几步 ,初始位置就是第 1 步
*/
public static void traversalChessboard(int[][] chessboard, int row, int column, int step) {
chessboard[row][column] = step;
//row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36
visited[row * X + column] = true; //标记该位置已经访问
//获取当前位置可以走的下一个位置的集合
ArrayList<Point> ps = next(new Point(column, row));
//对 ps 进行排序,排序的规则就是对 ps 的所有的 Point 对象的下一步的位置的数目，进行非递减排序
sort(ps);
//遍历 ps
while(!ps.isEmpty()) {
Point p = ps.remove(0);//取出下一个可以走的位置
//判断该点是否已经访问过
if(!visited[p.y * X + p.x]) {//说明还没有访问过
traversalChessboard(chessboard, p.y, p.x, step + 1);
}
}
//判断马儿是否完成了任务，使用step 和应该走的步数比较 ，
//如果没有达到数量，则表示没有完成任务，将整个棋盘置 0
//说明: step < X * Y 成立的情况有两种
//1.棋盘到目前位置,仍然没有走完
//2.棋盘处于一个回溯过程
if(step < X * Y && !finished ) {
chessboard[row][column] = 0;
visited[row * X + column] = false;
} else {
finished = true;
}
}
/**
* 功能： 根据当前位置(Point 对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多
有 8 个位置
* @param curPoint
* @return
*/
public static ArrayList<Point> next(Point curPoint) {
//创建一个 ArrayList
ArrayList<Point> ps = new ArrayList<Point>();
//创建一个 Point
Point p1 = new Point();
//表示马儿可以走 5 这个位置
if((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y -1) >= 0) {
ps.add(new Point(p1));
}
//判断马儿可以走 6 这个位置
if((p1.x = curPoint.x - 1) >=0 && (p1.y=curPoint.y-2)>=0) {
ps.add(new Point(p1));
}
//判断马儿可以走 7 这个位置
if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
ps.add(new Point(p1));
}
//判断马儿可以走 0 这个位置
if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
ps.add(new Point(p1));
}
//判断马儿可以走 1 这个位置
if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
ps.add(new Point(p1));
}
//判断马儿可以走 2 这个位置
if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
ps.add(new Point(p1));
}
//判断马儿可以走 3 这个位置
if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
ps.add(new Point(p1));
}
//判断马儿可以走 4 这个位置
if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
ps.add(new Point(p1));
}
return ps;
}
//根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数
public static void sort(ArrayList<Point> ps) {
ps.sort(new Comparator<Point>() {
@Override
public int compare(Point o1, Point o2) {
// TODO Auto-generated method stub
//获取到 o1 的下一步的所有位置个数
int count1 = next(o1).size();
//获取到 o2 的下一步的所有位置个数
int count2 = next(o2).size();
if(count1 < count2) {
return -1;
} else if (count1 == count2) {
return 0;
} else {
return 1;
}
}
});
}
}


```





## 4赫夫曼树

**赫夫曼编码**

### **1介绍**

- 赫夫曼编码也翻译为哈夫曼编码(Hufπ man Coding,又称霍夫曼编码,是一种编码方式,属于一种程序算法
- 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一
- 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间
- 赫夫曼码是可变字长编码(ⅥC)的一种。 Huffman于1952年提出一种编码方法,
- 称之为最佳编码

定长编码： 长度不会改变

### **2原理**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181403438.png)

 变长编码：

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181404106.png)

### **3赫夫曼编码： 会进行压缩**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202181404600.png)

#### **3.1赫夫曼压缩步骤**

1. 构建对应赫夫曼树
2. 得到对应赫夫曼树的赫夫曼编码
3. 根据赫夫曼编码转换为二进制数

#### **3.2解压步骤**

1. 得到对应的数组和赫夫曼编码表
2. 与之对应转换为赫夫曼编码然后得到字节数组输出

```

package a1数据结构.a7树结构.赫夫曼编码;

import javax.swing.plaf.synth.SynthOptionPaneUI;
import java.util.*;

public class Bianma {
    private static    HashMap<Byte, String> map = new HashMap<Byte, String>();
    public static void main(String[] args) {
        String DEMO = "i like like like java do you like a java";
//        List<NODE> list = tongji(DEMO);
//        //得到构建好的哈夫曼树
//        pre(hefu(list));
//        System.out.println("-------------------");
//        StringBuilder builder = new StringBuilder();
//        Map map = getcode(builder, "", hefu(list));
//        System.out.println("---");
//        System.out.println(map);
//
//        System.out.println("------------");
//        System.out.println(Arrays.toString(zip(DEMO.getBytes(), map)));
        byte[] bytes = yasuo(DEMO);
        System.out.println(Arrays.toString(bytes));

        System.out.println("--------------");
        System.out.println(decode(map, bytes));
        System.out.println();

    }


    //封装所有的方法
    public static  byte[] yasuo(String DEMO){
        //1得到哈夫曼树
        List<NODE> list = tongji(DEMO);
        //2得到对应的哈夫曼编码值
        StringBuilder builder = new StringBuilder();
        Map map = getcode(builder, "", hefu(list));
        //3压缩得到二进制的哈夫曼编码
        byte[] bytes = zip(DEMO.getBytes(), map);
        return bytes;
    }

    //1解析数组  这里的作用是根据字节数组转换到哈夫曼树编码的字符串
    public static String jiexi(byte demo, Boolean flag) {
        //保存字节
        int temp = demo;
        ////由于正数会报错 负数不会 判断一下  二进制位运算
        if (flag) {
            temp |= 256;
        }
        String str = Integer.toBinaryString(temp);
        if (flag) {
            return str.substring(str.length() - 8);
        } else {
            return str;
        }


    }
    //2将哈夫曼编码转换为原来的内容
    public static byte[] decode(Map<Byte, String> map, byte[] hafuman) {
        //1得到哈夫曼的字符串
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < hafuman.length; i++) {
            byte b = hafuman[i];
            //判断是否是最后一个节点
            Boolean flag = (i == hafuman.length - 1);
                builder.append(jiexi(b, !flag));

        }
        //3转换为原来的字符串
        HashMap<String, Byte> hashMap = new HashMap<>();
        for (Map.Entry<Byte, String> entry : map.entrySet()) {
          hashMap.put(entry.getValue(),entry.getKey());
        }
        //4创建集合存放数据
        ArrayList<Byte> list = new ArrayList<>();
        for (int i = 0; i < builder.length();) {
            int count=1;
            boolean flag=true;
            Byte b=null;
                while (flag){
                    String s = builder.substring(i, i+count);
                    b=hashMap.get(s);
                    if (b!=null){
                        flag=false;
                    }else {
                        count++;
                    }

                }
            list.add(b);
            i+=count;

        }
        //返回数据
        byte[] bytes = new byte[list.size()];
        for (int i = 0; i < list.size(); i++) {
            bytes[i]=list.get(i);
        }
        return bytes;
    }























    //3压缩赫夫曼编码 得到哈夫曼编码数组
    public  static byte[]  zip(byte[] bytes ,Map<Byte,String>  map){
        //构建缓冲区
        StringBuilder builder = new StringBuilder();
         //遍历数组进行拼接然后
        for (byte b : bytes) {
            builder.append(map.get(b));
        }
            //得到字节数组长度
        int len= (builder.length()+7)/8;
        byte[] count = new byte[len];
        int index=0;
        //按照二进制得到数据
        for (int i = 0; i < builder.length(); i+=8) {
            String demo;
            if (i + 8 > builder.length()) {
                demo = builder.substring(i);
            } else {
                demo = builder.substring(i, i + 8);
                count[index] = (byte) Integer.parseInt(demo, 2);
                index++;
            }
        }

            return  count;

    }
    //2获取赫夫曼树编码
    /*
    * @Param  stringbuilder 用户凭借编码
    * @Param   code 路径值 左节点为0 右节点为1
    * @Param   node  赫夫曼树节点
    *
    * */
    public  static   Map<Byte, String> getcode(StringBuilder stringBuilder,String code,NODE node){
        StringBuilder builder = new StringBuilder(stringBuilder);
        builder.append(code);
        String s = builder.toString();
        if (node!=null){
            //判断是否是叶子节点
            if (node.data==null){
                getcode(builder,"0",node.left);
                getcode(builder,"1",node.right);

            }else {
            map.put(node.data,builder.toString());
            }

        }
        return  map;
    }
    //1构建哈夫曼树
    public static NODE hefu(List<NODE> list){
        Collections.sort(list);
        while (list.size()>1) {
            //1得到最小2棵树取出然后得到一个二叉树（这里的条件是几个从小到大排序）
            NODE hefunode = list.get(0);
            NODE hefunode1 = list.get(1);
            NODE parent = new NODE(null,hefunode.weight+hefunode1.weight);
            parent.left=hefunode;
            parent.right=hefunode1;
            //移除已经构建好的元素
            list.remove(hefunode);
            list.remove(hefunode1);
            //加入以计算好的节点
            list.add(parent);
            //再次排序
            Collections.sort(list);
        }
        return  list.get(0);
    }

    //统计返回数组
    public static List<NODE>  tongji(String DEMO){
        //得到数组
        byte[] bytes = DEMO.getBytes();
        //统计次数
        ArrayList<NODE> list = new ArrayList<>();
        HashMap<Byte, Integer> map = new HashMap<Byte, Integer>();
        for (byte b : bytes) {
            Integer number= map.get(b);
            if (number==null){
                map.put(b,1);
            }else {
                number++;
                map.put(b,number);
            }

        }

        for (Map.Entry<Byte, Integer> entry : map.entrySet()) {
            list.add(new NODE(entry.getKey(),entry.getValue()));
        }
        return list;
    }

//前序遍历
    public  static void pre(NODE node) {
        if (node != null) {
            System.out.println(node);
        }
        if (node.left != null) {
            pre(node.left);
        }
        if (node.right != null) {
            pre(node.right);
        }
    }
//树结构
    public static class NODE implements Comparable<NODE> {
        public Byte data;
        public int weight;
        public NODE left;
        public NODE right;

        public NODE(Byte data, int weight) {
            this.data = data;
            this.weight = weight;
        }

        @Override
        public String toString() {
            return "NODE{" +
                    " data=" + data +
                    ", weight=" + weight +
                    '}';
        }

        @Override
        public int compareTo(NODE node) {
            return this.weight - node.weight;
        }


    }
}

```

