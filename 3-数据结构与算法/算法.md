# 算法



## 1排序算法

### **1排序算法的各种概念**

#### **1.1排序算法常见分类如下**

1. 插入排序（直接插入排序，希尔排序）
2. 选择排序（简单选择排序，堆排序）
3. 交换排序（冒泡排序，快速排序）
4. 归并排序
5. 基数排序

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161542658.png)

#### **1.2时间复杂度和空间复杂度**

##### **1.2.1算法的时间复杂度**

事后统计的方法

这种方法可行,但是有两个问题:一是要想对设计的算法的运行性能进行评测,需要实际运行该程序;二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,**这**

**种方式,要在同一台计算机的相同状态下运行,才能比较那个算法速度更快**

2)事前估算的方法

通过分析某个算法的时间复杂度来判断哪个算法更优

##### **1.2.2时间频度**

**时间频度**:一个算法花费的**时间**与算法中语句的**执行次数**成正比例,哪个算法

1中语句执行次数多,它花费时间就多。一个算法中的语句执行次数称为语句频

度或时间频度。记为T(n)。（**其实就是算法中语句执行的次数**）

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161548101.png)

**1忽略常数项（比如2n和2n+20来说，随着n的增加 他们的曲线越来越相等，所以20可以忽略）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549998.png)

**2忽略低次方（其实就是时间频度中低次方的可以忽略不计 列入2n~3和2n~3+3n+1中的3n+1可以直接忽略不计）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549852.png)

**3忽略系数（立方不能忽略）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161549146.png)

**时间复杂度之同数量极函数（即和T（n）相除的极限值不为0的常数的函数）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161550293.png)

#### **1.3时间复杂度常见类型**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551276.png)

##### **1.3.1常数阶 （无循环）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551187.png)

##### **1.3.2对数阶（一重循环  循环体数据\*2）**

![img](D:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CqqDBD1F84E1C986CF725E8AFDDB2DCE08F%5C37b347947e044c48b3efb9eda396924f%5Cclipboard.png)

##### **1.3.3线性阶（一重循环 里面数据无翻倍操作）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161551289.png)

##### **1.3.4线性对数对数阶**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552854.png)

##### **1.3.5平方阶（两重循环）**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552103.png)

#### **1.4算法的平均算法复杂度和最坏复杂度**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161552791.png)

##### **1.4.1算法的空间复杂度**

**基本介绍**

- 类似于时间复杂度的讨论,一个算法的空间复杂度( Space Complexity)定义为该算法所耗费的存储空间,它也是问题规模n的函数。
- 空间复杂度 Space Complexity是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关,它随着n的增大而增大,当n较大时,将占用较多的存储单元,例如快速排序和归并排序算法就属于这种情况
- 在做算法分析时,主要讨论的是时间复杂度。从用户使用体验上看,更看重的程序执行的速度。一些缓存产品 redis, memcache和算法(基数排序)本质就是用空间换时间

### **2基础算法**

#### **2.1冒泡排序(O(N^2)**

##### **2.1.1简单概述：**

（从小到大顺序排序，有序排序）（这里的思想其实就是将相邻两个元素比较然后得到最大值放在数组最后 然后循环遍历）

##### **2.1.2基本介绍**

冒泡排序( Bubble Sorting)的基本思想是:通过对待排序序列从前向后(从下标较小的元素开始),依次比较相邻元素的值,若发现逆序则交换,使值较大的元素逐渐从前移向后部,就象水底下的气泡一样逐渐向上冒。

因为排序的过程中,各元素不断接近自己的位置,如果一趟比较下

来没有进行过交换,就说明序列有序,因此要在排序过程中设置

—个标志fag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优

化,可以在冒泡排序写好后,在进行

##### **2.1.3排序算法图解**

（就是由左向右比较相邻的元素然后一个数组的最大值，以此类推）

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161601735.png)

##### **2.1.4代码如下**

```
package a6排序算法;

import java.util.Arrays;
//排序算法思路
//将数组相邻的两个叔互相比较然后每次排序将最大的放在最后
public class Paixudemo1 {
    public static void main(String[] args) {
        //1实现数组
        int array[]= {-1,30,3,20,10};
        //代替节点
        int temp=0;
        //根据索引遍历
        for (int j = 0; j < array.length-1; j++) {
            //比较相邻数据大小
            for (int i = 0; i < array.length - 1-j; i++) {
                if (array[i]>array[i+1]){
                    temp=array[i];
                    array[i]=array[i+1];
                    array[i+1]=temp;
                }
            }
        }

        System.out.println(Arrays.toString(array));

    }
}

```

#### **2.2选择排序**

##### **2.2.1简单概述：**

**（自定义规则选择数据排序）（得到最小值然后将最小值和开头交换）**

##### **2.2.2图解如下**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161603462.png)

##### **2.2.3选择排序代码代码如下**

```
package 选择算法;

import java.util.Arrays;

public class Xuanze {
    public static void main(String[] args) {
        //定义数组
        int array[]={4,2,44,1};
            //排序几次
        for (int j = 0; j < array.length-1; j++) {
            int min=array[j];
            int minindex=j;
            //得到最小值和最小值的索引
            for (int i = 1+j; i < array.length ; i++) {
                if (array[i]<min){
                    min=array[i];
                    minindex=i;
                }

            }
            //将最小值和开头交换
            if (minindex!=j) {
                array[minindex] = array[j];
                array[j] = min;
            }
            System.out.println(j+"次"+Arrays.toString(array));
        }


    }
}

```

#### **2.3插入排序**

##### **2.3.1思路解析**

插入排序( insertion Sorting))的基本思想是:**个待排序的元素看成为个有序表和一个无序表,开始时有序表中只包含一个元素,无序表中包含有n-1个元素,排序过程中每次从无序表中取出第一个元素,把它的排序码依次与有序表元素的排序码进行比较,将它插入到有序表中的适当位置,使之成为新的有序表。**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161721379.png)

我再来详细的说一下插入排序 其实就是在一个数组中一开始默认第一个元素为有序表，后面的元素为无序表 流程如下

1比较待插入的元素与有序表最后一个元素比较大小 ，如果比他大的话直接插在有序表的最后也就是后移一位。如果比他小的话，比较的索引值--，在往前比较，然后比他大的又后移，直到前面的元素比他小时，加在该索引的后面。

##### **2.3.2代码如下**

```
package a8插入算法;

import java.util.Arrays;

//插入排序的思路是分为一个有序表和无序表
//一开始设定一个值放在有序表中，其他的都放在无序表中，然后取无需表中的元素与有序表中的元素比较  知道无需表中无元素为止
//每次插入的时候与有序表的最后一个元素进行比较 如果小于的话，比他大的元素后移，然后继续比较，知道前面没有比他大的值
public class Demo {

    public static void main(String[] args) {
        int array[]= {31,30,29,20,10};

        for (int i = 1; i < array.length; i++) {
            int insertval=array[i];
            int  inserindex=i-1;
            while(inserindex>=0   && insertval<array[inserindex]){
                array[inserindex+1]=array[inserindex];
                inserindex--;
            }
            array[inserindex+1]=insertval;
        }

        System.out.println("第一次排序的数组为"+ Arrays.toString(array));
    }
}


```

  					

#### **2.4希尔排序**

##### **2.4.1思路如下**

其实就是将数组的长度/2然后分组比较优化的方式万一数据最小的值在数组最后，插入排序就需要从最后一直移位多次，所有希尔排序实在插入排序的基础上进行优化。

这里关于希尔排序的分组规律是如何排序的？请看下面的解释。

链接解释  [理解希尔排序的排序过程_razorEdge的博客-CSDN博客_希尔排序的详细过程](https://blog.csdn.net/weixin_37818081/article/details/79202115)

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161721717.png)

依上图得：排序文件有10个记录，其关键字分别是27 38 65 97 76 13 27* 49 55 4. 增量序列的取值依次为：5，2，1。 第一趟排序时，d1=5，整个文件被分成5组：（27，13），（38，27*），（65，49），（97，55），（76，4）各组中的第一个记录都自成一个有序区，我们依次将各组的第2个记录直至**最后一个**。 第一趟排序结果：13 27* 49 55 4 27 38 65 97 76 第二趟排序时，d2=2 ，图如上。 第二趟排序结果：4 27* 13 27 38 55 49 65 97 76 最后一趟排序时，d3=1，即是对整个文件做直接插入排序，结果即为有序文件。

//这里的注意点是分完组后使用的是**插入排序 插入排序  插入排序 重要的事说三遍！**

##### **2.4.2希尔排序移位法代码实现**

```
package 希尔算法;

import java.util.Arrays;

public class Shellsuanfa {
    public static void main(String[] args) {
        int arrahy[] = {2, 3, 1, 5, 4, 7, 8, 9, 10, 0};
        int temp = 0;
        //重复操作

        //分组
        for (int gap = arrahy.length / 2; gap > 0; gap /= 2) {
            //第一轮辅助分组
            //后一组
            for (int i = gap; i < arrahy.length; i++) {
           
                System.out.println("当前的i为"+j+",与增量比较为"+(j+gap));
                //比较
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arrahy[j] > arrahy[j+gap]) {
                        temp = arrahy[j];
                        arrahy[j] = arrahy[j+gap];
                        arrahy[j+gap] = temp;
                    }
                }
            }

            System.out.println("第"+gap+"轮" + Arrays.toString(arrahy));
        }
    }
}

```

希尔排序这里又看不懂了 做一个详细的解释  ：

关于分组问题   分组后采用的是插入排序

第一轮的比较：

```
当前的i为0,与增量比较为5
当前的i为1,与增量比较为6
当前的i为2,与增量比较为7
当前的i为3,与增量比较为8
当前的i为4,与增量比较为9
第5轮[2, 3, 1, 5, 0, 7, 8, 9, 10, 4]
```

第二轮的比较：

```
当前的i为0,与增量比较为2
当前的i为1,与增量比较为3
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
当前的i为4,与增量比较为6
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为5,与增量比较为7
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
当前的i为6,与增量比较为8
当前的i为4,与增量比较为6
当前的i为2,与增量比较为4
当前的i为0,与增量比较为2
当前的i为7,与增量比较为9
当前的i为5,与增量比较为7
当前的i为3,与增量比较为5
当前的i为1,与增量比较为3
第2轮[0, 3, 1, 4, 2, 5, 8, 7, 10, 9]

```

第三轮的比较：

```
当前的i为0,与增量比较为1
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为7,与增量比较为8
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
当前的i为8,与增量比较为9
当前的i为7,与增量比较为8
当前的i为6,与增量比较为7
当前的i为5,与增量比较为6
当前的i为4,与增量比较为5
当前的i为3,与增量比较为4
当前的i为2,与增量比较为3
当前的i为1,与增量比较为2
当前的i为0,与增量比较为1
第1轮[0, 1, 2, 3, 4, 5, 7, 8, 9, 10]

进程已结束,退出代码0

```



插入排序的理解就是看成一个无序表和一个有序表   

第一轮的排序 特别容易理解 就是两两一组  特别好理解

第二轮的排序  注意注意   排序规则不太易懂了  虽然理解成2组 但是代码执行的过程中却是交替执行的

列如   13   2 4    35    46  ····



![image-20220216172916480](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161729406.png)



##### **2.4.3希尔排序移位法**

```
//对交换式的希尔排序进行优化->移位法
public static void shellSort2(int[] arr) {
// 增量 gap, 并逐步的缩小增量
for (int gap = arr.length / 2; gap > 0; gap /= 2) {
// 从第 gap 个元素，逐个对其所在的组进行直接插入排序
for (int i = gap; i < arr.length; i++) {
int j = i;
int temp = arr[j];
if (arr[j] < arr[j - gap]) {
while (j - gap >= 0 && temp < arr[j - gap]) {
//移动
arr[j] = arr[j-gap];
j -= gap;
}
//当退出 while 后，就给 temp 找到插入的位置
arr[j] = temp;
}
}
}
}
}

```

#### **2.5快速排序**

##### **2.5.1思路如下：**

（对冒泡排序的改进：其实就是先选择1个数然后分割比较，左边的数比他小，右边的数比他大）

##### **2.5.2图解如下：**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161758687.png)

###### **2.5.3代码实现：（这里传入的值是数组的最大索引和最小索引）**

```
package 快速排序算法;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;

/*
基于冒泡排序的升级版
思路是定义一个数然后左边的比他小，右边的比他大
* */
public class Querykuai {
    public static void main(String[] args) {
        int[] ints = new int[8000000];
        int[] a = {1, -1, 3, 2, 0, 9};

        Date date = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String s = format.format(date);
        System.out.println(s
        );
        for (int i = 0; i < ints.length; i++) {
            ints[i]= (int) (Math.random()*8000000);

        }
        System.out.println(format.format(new Date()));
    }

    /*
     * @param */
    public static void queryint(int[] array, int left, int right) {
        int l = left;//左下标
        int r = right;//右下标
        int temp;
        int pivot = array[(l + r) / 2];//定义一个数区分
        //比他小的放在左边
        while (l < r) {
            while (array[l] < pivot) {
                l += 1;

            }
            //比他大的放在右边
            while (array[r] > pivot) {
                r -= 1;

            }
            //判断是否已经全部排序完
            if (l >= r) {
                break;
            }
            //交换
            temp = array[l];
            array[l] = array[r];
            array[r] = temp;

            if (array[l] == pivot) {
                r -= 1;

            }
            if (array[r] == pivot) {
                l += 1;
            }


        }
        if (l == r) {
            l += 1;
            r -= 1;

        }

        //递归
        if (r > left) {
            queryint(array, left, r);
        }
        if (right > l) {
            queryint(array, l, right);
        }


    }
}

```

#### **2.6归并排序**

##### **2.6.1思路分析：**

其实归并排序就是将数组分成多个数组然后多次排序最后整合到一个新的数组当中

归并排序( MERGE- SORT〕是利用**归并**的思想实现的排序方法,该算法采用经典的分治( divide and-conquer)策略(分治法将问题分( divide)成一些**小的问题**然后**递归求解**,而治( conquer)的阶段则将分的阶段得到的各答案"修补"在起,即分而治之

##### **2.6.2图解分析**

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161759647.png)

##### **2.6.3归并代码实现**

```

package 归并排序;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;   

/*
* 其实就是将排序一直分组然后进行copy复制*/
public class Guibin {
    public static void main(String[] args) {
            int[] arr={1,-1,80,70,98,100};
        int[] temp=new int[arr.length/2];
            mergesort(arr,0,arr.length-1,temp);
        System.out.println("归并排序后"+ Arrays.toString(temp));
    }

    public static  void mergesort(int[]arr,int left,int right,int []temp){
  if (left<right){
      int mid=(left+right)/2;
      //左分治
      mergesort(arr,left,mid,temp);
      //右分治
      mergesort(arr,mid+1,right,temp);
      merge(arr,left,mid,right,temp);


  }
    }

    /**
     *
     * @param arr   需要排序的数组
     * @param left  左边的索引
     * @param right 右边的索引
     * @param mid   中间索引
     * @param temp  初始数组
     */
    public static  void merge(int[]arr,int left,int right,int mid,int []temp) {
        System.out.println("测试");
        int i = left;
        int j = mid + 1;
        int t = 0;//可变化 temp的可变化索引
        //1索引变化就停止
        //这里是分治
        while (i <= mid && j <= right) {
            if (arr[i]<=arr[j]){
                temp[t]=arr[i];
                t+=1;
                i+=1;
            }else {
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }
        }
            //说明还有i 全部填充
            while (i <= mid) {
                temp[t]=arr[i];
                t+=1;
                i+=1;
            }
            //说明还有i 全部填充
            while (j <= right) {
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }
            //在在这里就是将分组的数组认真排序然后放入数组当中
            t=0;
            int tempindex=left;
            while (tempindex<=right){
                arr[tempindex]=temp[t];
                t+=1;
                tempindex+=1;
            }


    }
}


```

#### **2.7基数排序（桶排序）**

##### **2.7.1思想如下：**

将所有待比较数值统一为同样的数位长度,数位较短的数前面补零。然后,从最低位开始,依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。这样说明,比较难理解,下面我们看一个图文解释,理解基数排序的步骤

//基数排序的思路其实就是先准备0-9这10个桶，然后根据数组元素的位数进行放置，另外排序的次数取决于数组中最大元素的位数，列如4005 ，这个数组最大值元素的位数为4.所以需要排序4次

//基数排序的缺点就是数据不能够为负数  原因是因为基数排序在使用数组存放在那个桶的时候需要得到余数 ，而基数排序的桶都是正数。

排序图列说明

#### **2.8堆排序（使用树结构）**

##### **2.8.1思想如下**

1. 将待排序序列构造成一个大顶堆，此时,整个序列的最大值就是堆顶的根节点。
2. 将其与末尾元素进行交换,此时末尾就为最大值然后将剩余n-1个元素重新构造成一个堆,这样会得到n个元素的次小值。
3. 如此反复执行,便能得到一个有序序列了。
4. 可以看到在构建大顶堆的过程中,元素的个数逐渐减少,最后就得到一个有序序列了

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161800084.png)

##### **2.8.2相关名词**

大顶堆： 父节点大于左右子节点 左右子节点没有要求

小顶堆： 父节点小于左右子节点 左右子节点没有要求

![img](https://gitee.com/zhou-kaifa/images/raw/master/Images/202202161800588.png)

根据我的理解就是先把大顶堆构建出来  ，然后在逐渐缩小数组的长度，然后交换进行遍历 ， 这里需要注意的点是 大顶堆的排序次数为数组的长度/2-1

**2.8.3代码如下**

```
package a16堆排序;

import java.util.Arrays;

public class Duipaix {
    public static void main(String[] args) {
        int [] array={4,6,8,5,9};
zuizhong(array);
        System.out.println(Arrays.toString(array));

    }
    public static  void  zuizhong(int [] array){
        //构建大顶堆的次数
        for (int i = array.length / 2 - 1; i >= 0; i--) {
            duipaixu(array,i, array.length);
        }
        //减少排序元素  多次排序
        for (int i = array.length - 1; i >= 0; i--) {
            //交换
            int temp=array[i];
            array[i]=array[0];
            array[0]=temp;
            duipaixu(array,0,i);
        }

    }
    //构建大顶堆
    public static void  duipaixu(int [] array,int i, int length){

            int temp =array[i];
            for (int k=2*i+1; k<length; k=k*2+1) {
                if (k+1<length && array[k+1]>array[k]) {
                    k++;

                }
                if (array[k]>array[i]){
                    array[i]=array[k];
                    i=k;
                }else {
                    break;
                }
                array[k]=temp;
        }


    }
}

```

