



# 数据结构

## **1数据结构的分类**

### **1.1线性结构**

- **线性结构**作为最常用的数据结构,其特点是数据元素之间存在一对一的线性关系
- **线性结构**有两种不同的存储结构,即**顺序存储结构**和**链式存储结构**。**顺序存储**的线性表称为**顺序表**,顺序表中的存储元素是**连续**的
- **链式存储的线性表称为链表**,链表中的存储元素**不一定是连续的**,元素节点中存放数据元素以及相邻元素的地址信息
- 线性结构常见的有:**数组、队列、链表和栈**

### **1.2非线性结构**

- **非线性结构**包括**:二维数组,多维数组,广义表,树结构,图结构**

## **2稀疏数组**

### **2.1稀疏数组的概念**

- 当一个数组中大部分元素为0,或者为同一个值的数组时,可以使用稀疏数组来保存该数组。
- 稀疏数组的处理方法是记录数组一共有几行几列,有多少个不同的值。
- 把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模。
- 稀疏数组的优点：减少了存储大量相同值。只储存不同的值。

###  **2.2稀疏数组的使用场景：**

案列如下：

![img](http://inis.inis1719.cn/202206021239512.png)

![img](http://inis.inis1719.cn/202206021239514.png)

### **2.2.1稀疏数组的代码实现**

```java
package 稀疏数组;

public class 五子棋 {
    public static void main(String[] args) {
        //1构建棋盘二维数组
        int[][] ints = new int[11][11];
        //2赋值
        ints[1][2] = 1;
        ints[2][3] = 2;
        //3打印二维数组
        System.out.println("原始二维数组");
        for (int[] anInt : ints) {
            for (int i : anInt) {
                System.out.printf("%d\t", i);
            }
            System.out.println();
        }
        //4得到数据中有效的值
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {

                if (ints[i][j] != 0) {
                    sum++;
                }
            }
        }
        System.out.println("当前二维数组有效个数为" + sum);
/*   稀疏数组的模板
   行  列    值
* row col   val
* 11  11     2    稀疏数组第一行值 的是二维数组总共11行11列  其中只有2 个有值
   1  2      1    这里指的是在二维数组中第2行第3列的值为1   （下标从0开始）

* */
        //5创建稀疏数组array
        int[][] array = new int[sum + 1][3];
        array[0][0] = 11;
        array[0][1] = 11;
        array[0][2] = sum;
        System.out.println("原始稀疏数组");
        for (int[] ints1 : array) {
            for (int i : ints1) {
                System.out.printf("%d\t", i);
            }
            System.out.println();
        }
        //6遍历二维数组给稀疏数组赋值
        int count = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {

                if (ints[i][j] != 0) {
                    count++;
                    array[count][0] = i;
                    array[count][1] = j;
                    array[count][2] = ints[i][j];
                }
            }
        }
        //7遍历稀疏数组
        System.out.println("赋值稀疏数组");
        for (int[] ints1 : array) {
            for (int i : ints1) {
                System.out.printf("%d\t", i);
            }
            System.out.println();
        }
        //8根据稀疏数组转换为二维数组
        System.out.println("根据稀疏数组转换为二维数组并赋值如下");
        int[][] ints1 = new int[array[0][0]][array[0][1]];

/*
* 
* //定义一个整型数组:3行4列
int a[][] = new int[3][4];
//获取行数---3行
int lenY = a.length;
//获取列数---4列
int lenX = a[0].length;*/
        for (int i = 1; i < array.length; i++) {
            ints1[array[i][0]][array[i][1]]=array[i][2];
        }
        for (int[] ints2 : ints1) {
            for (int i : ints2) {
                System.out.printf("%d\t",i);
            }
            System.out.println();
        }

    }

}

```

## **3 队列**

### **3.1队列的概念：**

**特点**：**有序列表** 、**先进先出**。

![img](http://inis.inis1719.cn/202206021239516.png)

### **3.2队列的使用场景**

![img](http://inis.inis1719.cn/202206021239517.png)

#### **3.2.1实现思路：**

- 数组模拟队列
- 加数据是在队列的尾部加 所以rear会增加
- 取数据的时候font增加(font是头部  rear是)

![img](http://inis.inis1719.cn/202206021239518.png)

**3.2.2代码实现**

自定义队列类

```
package 数组;

public class QueryArray {
    //数组最大长度
    private int max_size;
    //队列尾的前一个
    private int rear;
    //队列头的前一个
    private int front;
    //数组
    private int[] array;

    //定义构造方法
    private QueryArray(int size) {
        size = max_size;
        array = new int[size];
        rear = -1;
        front = -1;
    }

    //判断数组是否为空
    public boolean isempy() {
        //这里看上图
        return rear == front;
    }

    //判断数组是否满
    public boolean isfull() {
        return rear == max_size - 1;
    }                   
    
    

    //添加队列
    public void addquery(int n) {
        if (isfull()) {
            System.out.println("队列数据已满");
        } else {
             rear++;
            array[rear] = n;
        }
    }
    public int getquery() {
        if (isempy()) {
            throw new RuntimeException("队列为空");
        }
        front++;
        return  array[front];
    }
    //展示所有数据
    public  void  show(){
        if (isempy()){
            System.out.println("队列为空");
            return;
        }   for (int i : array) {
            System.out.println(i);
        }
    }
}

```



```
package 数组;

import java.util.Scanner;

public class querydemo {
    public static void main(String[] args) {
        QueryArray array = new QueryArray(30);
        boolean toop = true;
        char key;
        while (toop) {
            Scanner scanner = new Scanner(System.in);
            System.out.println("s,查看全部数据");
            System.out.println("g,获取数据");
            System.out.println("e,是否为空");
            System.out.println("f,是否已满");
            System.out.println("a,插入队列");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    array.show();
                    break;
                case 'g':
                    int i = array.getquery();
                    System.out.println(i);
                    break;
                case 'e':
                    System.out.println(array.isempy());
                    break;
                case 'f':
                    System.out.println(array.isfull());
                    break;
                case 'a':
                    System.out.println("请你输入一个数");
                    int anInt = scanner.nextInt();
                    array.addquery(anInt);
                    break;
                case 't':
                    scanner.close();
                    toop=false;
                    break;
                default:
                    break;
            }
            System.out.println("程序退出");


        }
    }
}

```



#### **3.2.3数组环形队列实现**

思路实现

这里的思路我画个逻辑图来表示

![img](http://inis.inis1719.cn/202206021239519.png)

![img](http://inis.inis1719.cn/202206021239520.png)

```
class CircleArray {
private int maxSize; // 表示数组的最大容量
//front
变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说
arr[front] 就是队列的第一个元素
front的初始值 = 0
private int front;
//rear
变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置.
因为希望空出一个空间做为约定.
//rear的初始值 = 0
private int rear; //队列尾
private int[] arr; //该数据用于存放数据, 模拟队列
public CircleArray(int arrMaxSize) {
maxSize = arrMaxSize;
arr = new int[maxSize];
}
// 判断队列是否满
public boolean isFull() {
return (rear + 1) % maxSize == front;
}
// 判断队列是否为空
public boolean isEmpty() {
return rear == front;
}
// 添加数据到队列
public void addQueue(int n) {
// 判断队列是否满
if (isFull()) {
System.out.println("队列满，不能加入数据~");
return;
}
//直接将数据加入
arr[rear] = n;
//将 rear 后移, 这里必须考虑取模
rear = (rear + 1) % maxSize;
}
// 获取队列的数据,
出队列
public int getQueue() {
// 判断队列是否空
if (isEmpty()) {
// 通过抛出异常
throw new RuntimeException("队列空，不能取数据");
}
// 这里需要分析出 front 是指向队列的第一个元素
// 1.
先把 front 对应的值保留到一个临时变量
// 2.
将 front 后移, 考虑取模
// 3.
将临时保存的变量返回
int value = arr[front];
front = (front + 1) % maxSize;
return value;
}
// 显示队列的所有数据
public void showQueue() {
// 遍历
if (isEmpty()) {
System.out.println("队列空的，没有数据~~");
return;
}
//
思路：从 front 开始遍历，遍历多少个元素
//
动脑筋
for (int i = front; i < front + size() ; i++) {
System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
}
}
// 求出当前队列有效数据的个数
public int size() {
// rear = 2
// front = 1
// maxSize = 3
return (rear + maxSize - front) % maxSize;
}
// 显示队列的头数据， 注意不是取出数据
public int headQueue() {
// 判断
if (isEmpty()) {
throw new RuntimeException("队列空的，没有数据~~");
}
return arr[front];
}
}

```

###  **3.3约瑟夫问题解决**

思路如下

![img](http://inis.inis1719.cn/202206021239521.png)

```
/*
* 约瑟夫问题解决
* starterno  从第几个开始
* nums 总数
* m  数第几个
* */
    public void yuesefu(int Startno ,int nums ,int m){
       Boy helper=first;
       while (true){
           if (helper.next==first){
               break;
           }
           helper=helper.next;
       }

       //后移数数指针
        for (int i = 0; i < Startno - 1; i++) {
                first=first.next;
                helper=helper.next;
        }
        //开始叔叔
        while (true){
            if (helper==first){
                System.out.println("当前小孩只剩一个"+"编号为"+helper.no);
                break;
            }
            for (int i = 0; i < m - 1; i++) {
                first=first.next;
                helper=helper.next;
            }
            System.out.println("出去小孩的编号为"+first.no);
            first=first.next;
                helper.next=first;
        }
        System.out.println("最后留在圈内的小孩编号是"+first.no);

    };


```

## **4链表**

### **4.1链表的介绍**

- 特点：链表是有序的  但是存储就像链式编程一样节点连接下一个节点

![img](http://inis.inis1719.cn/202206021239522.png)

### **4.2代码实现**

#### **4.2.1创建模拟实体类**

```
package a3链表.单链表;

public class Person {
    //编号
    int no;
    //名字
    String name;
    //昵称
    String nickname;
    //下一个节点
    Person next;
    //构造方法
    public   Person(int ano,String aname,String anickname){
        this.no=ano;
        this.name=aname;
        this.nickname=anickname;
    }

    @Override
    public String toString() {
        return "Person{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```

#### **4.2.2创建链表类**

```
package a3链表.单链表;

public class Linklistarray {
        //1设置头节点
        Person head = new Person(0, "", "");
        ////添加数据到链表
    public void add(Person person){
        //头节点不能动 创建辅助头
        //这里的链表是顺序添加 所以插入的是一定是在最后一个元素后移插入的  所以我们需要先找到最后一个元素
        // 而最后一个元素的特点就是他的next节点为null
        Person temp=head;
        while (true){
            if (temp.next==null){
                break;
            }
            //一直后移知道next节点为null
            temp=temp.next;
        }
        //得到链表的最后，当while结束时就是最后
        temp.next=person;
    }
    public void update(Person person){
        boolean isupdat=false;
        Person temp= head.next;
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        while (true){
            if (temp==null){
                break;
            }
            if (temp.no==person.no){
                isupdat=true;
                    break;
            }
            temp=temp.next;
            if (isupdat){
                temp.name= person.name;
                temp.nickname=person.nickname;
            }else {
                System.out.println("没有找到");
            }
        }
    }    public void addorby(Person person){
        //头节点不能动 创建辅助头
        Person temp=head;
        //定义一个初始boolean值
        boolean flah=false;
        while (true){
            if (temp.next==null){
                break;
            }
            //找到插入的位置
            if (temp.next.no> person.no){
                break;

            }if (temp.next.no==person.no){
                flah=true;
                break;
            }
            temp=temp.next;
        }

        //添加顺序链表
if (flah){
    System.out.println("已存在"+person.no);
}else {
    //添加到链表中
     person.next=temp.next;
     temp.next=person;
}
    }

    //遍历链表
    public void list(){
        //头节点next为null时表示未插入数据
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        Person temp=head.next;
        while (true){

            if (temp==null){
                break;
            }
            System.out.println(temp);
            //这里还是指针后移知道next节点为空
            temp=temp.next;
        }

    }


}

```



#### **4.2.3顺序添加到链表**

```
public void addorby(Person person) {
    //头节点不能动 创建辅助头
    Person temp = head;
    //定义一个初始boolean值
    boolean flah = false;
    while (true) {
        //找到最后一个节点
        if (temp.next == null) {
            break;
        }
        //找到插入的位置 这里判断的是temp的下一个节点 如果比传入的no大就应该插入到temp和temp下一个节点之间
        if (temp.next.no > person.no) {
            break;

        }
        //编号已存在
        if (temp.next.no == person.no) {
            flah = true;
            break;
        }
        //后移
        temp = temp.next;
    }
    //添加顺序链表
    if (flah) {
        System.out.println("已存在" + person.no);
    } else {
        //添加到链表中
        //这里的顺序是先将temp的尾部的上一个节点指定
        person.next = temp.next;
        //然后指定后一个节点
        temp.next = person;
    }
}

```

逻辑图图解

![img](http://inis.inis1719.cn/202206021239523.png)

测试

```
package 链表.单链表;

public class Linktest {
    public static void main(String[] args) {
        Linklistarray linklistarray = new Linklistarray();
        linklistarray.add(new Person(0,"1","22"));
        linklistarray.add(new Person(0,"2","22"));
        linklistarray.add(new Person(0,"3","22"));
        linklistarray.add(new Person(0,"4","22"));
    linklistarray.list();
    }
}

```

#### **4.2.4修改方法**

```
public void update(Person person) {
    boolean isupdat = false;
    Person temp = head.next;
    if (head.next == null) {
        System.out.println("链表为空");
        return;
    }
    while (true) {
        if (temp == null) {
            break;
        }
        if (temp.no == person.no) {
            isupdat = true;
            break;
        }

        temp = temp.next;
    }
    if (isupdat) {
        temp.name = person.name;
        temp.nickname = person.nickname;
    } else {
        System.out.println("没有找到");
    }
}

```



#### **4.2.5删除方法**

```
 public void delete(int no){
        boolean flag=false;
        Person temp = head;
        if (temp.next==null){
            System.out.println("链表为空");
        }
        while (true){
            if (temp.next==null){
                flag=true;
                break;
            }
            if (no== temp.next.no){
                break;
            }
            temp=temp.next;
        }
        if (flag){
            System.out.println("当前没有这个编号");
            return;
        }
temp.next=temp.next.next;

    }

```

### **4.3单向链表面试题**

#### **4.3.1求单链表中有效节点的个数**

```
public  int length(){
        int count =0;
    Person person = head.next;
    boolean flog=false;
    if (person==null){
        System.out.println("链表为空");
    }
    while (true){
        if (person==null){
            flog=true;
            break;
        }else{
            count++;

        }
        person=person.next;
    }
        return  count;
}

```

#### **4.3.2查找单链表中的倒数第 k 个结点**

```
 查找单链表中的倒数第 k 个结点 【新浪面试题】
代码演示:
//查找单链表中的倒数第 k 个结点 【新浪面试题】
//思路
//1. 编写一个方法，接收 head 节点，同时接收一个 index
//2. index 表示是倒数第 index 个节点
//3.
先把链表从头到尾遍历，得到链表的总的长度 getLength
//4.
得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到
//5.
如果找到了，则返回该节点，否则返回 nulll
public static HeroNode findLastIndexNode(HeroNode head, int index) {
//判断如果链表为空，返回 null
if(head.next == null) {
return null;//没有找到
}
//第一个遍历得到链表的长度(节点个数)
int size = getLength(head);
//第二次遍历 size-index 位置，就是我们倒数的第 K 个节点
//先做一个 index 的校验
if(index <=0 || index > size) {
return null;
}
//定义给辅助变量， for 循环定位到倒数的 index
HeroNode cur = head.next; //3 // 3 - 1 = 2
for(int i =0; i< size - index; i++) {
cur = cur.next;
}
return cur;
}

```

#### **4.3.3单链表的反转**

```
3)
单链表的反转【腾讯面试题，有点难度】

思路分析图解
 代码实现
//将单链表反转1
public static void reversetList(HeroNode head) {
//如果当前链表为空，或者只有一个节点，无需反转，直接返回
if(head.next == null || head.next.next == null) {
return ;
}
//定义一个辅助的指针(变量)，帮助我们遍历原来的链表
HeroNode cur = head.next;
HeroNode next = null;// 指向当前节点[cur]的下一个节点
HeroNode reverseHead = new HeroNode(0, "", "");
//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead
的最前端
//动脑筋
while(cur != null) {
next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用
cur.next = reverseHead.next;//将 cur 的下一个节点指向新的链表的最前端
reverseHead.next = cur; //将 cur 连接到新的链表上
cur = next;//让 cur 后移
}
//将 head.next 指向 reverseHead.next , 实现单链表的反转
head.next = reverseHead.next;
}

```

**4.3.4从尾到头打印单链表** 

```
4)
从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】

思路分析图解

代码实现
写了一个小程序，测试 Stack 的使用
package com.atguigu.linkedlist;
import java.util.Stack;



//演示栈 Stack 的基本使用
//链表反转
public  void  reserve (){
    //使用栈先进后出的规则来进行反转
        Stack<Person> stack = new Stack<>();
    Person temp = head.next;
    while (temp!=null){
        stack.push(temp);
        temp=temp.next;


    }
   while (stack.size()>0){
       System.out.println(stack.pop());
   }

}

}

单链表的逆序打印代码:
//方式 2：
//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效
果
public static void reversePrint(HeroNode head) {
if(head.next == null) {
return;//空链表，不能打印
}
//创建要给一个栈，将各个节点压入栈
Stack<HeroNode> stack = new Stack<HeroNode>();
HeroNode cur = head.next;
//将链表的所有节点压入栈
while(cur != null) {
stack.push(cur);
cur = cur.next; //cur 后移，这样就可以压入下一个节点
}
//将栈中的节点进行打印,pop 出栈
while (stack.size() > 0) {
System.out.println(stack.pop()); //stack 的特点是先进后出
}
}

```

 	

### 	**4.4双向链表**

![img](http://inis.inis1719.cn/202206021239524.png)

单双链表的区别:

- 单向链表方向一致性,双向链表可以向前可以向后.
- 可以自我删除.

![img](http://inis.inis1719.cn/202206021239525.png)

### **4.5 单向环形链表**

单向环形链表和单向链表的区别:

- 单向链表最后一个节点的next(下一个节点)为null,
- 单向环形链表最后一个节点的next则是第一个节点first

#### **4.5.1Joseph(约瑟夫、约瑟夫环)问题**

joseph问题为:设编号为1,2,…n的n个人围坐一圈,约定编号为k(1<<n)的人从1开始报数,数

到m的那个人出列,它的下一位又从1开始报数,数到m的那个人又出列,依次类推,直到所有人出列为止,由

此产生一个出队编号的序列

提示:用一个不带头结点的循环链表来处理 Joseph问题:先构成一个有n个结点的单循环链表,然后由k结

点起从1开始计数,计到m时,对应结点从链表中删除,然后再从被删除结点的下一个结点又从1开始计数,直

到最后一个结点从链表中删除算法结束

![img](http://inis.inis1719.cn/202206021239526.png)

![img](http://inis.inis1719.cn/202206021239527.png)

代码实现:

```
public class Josepfu {
public static void main(String[] args) {
// 测试一把看看构建环形链表，和遍历是否 ok
CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
circleSingleLinkedList.addBoy(125);// 加入 5 个小孩节点
circleSingleLinkedList.showBoy();
//测试一把小孩出圈是否正确
circleSingleLinkedList.countBoy(10, 20, 125); // 2->4->1->5->3
}
}
// 创建一个环形的单向链表
class CircleSingleLinkedList {
// 创建一个 first 节点,当前没有编号
private Boy first = null;
// 添加小孩节点，构建成一个环形的链表
public void addBoy(int nums) {
// nums 做一个数据校验
if (nums < 1) {
System.out.println("nums 的值不正确");
return;
}
Boy curBoy = null; // 辅助指针，帮助构建环形链表
// 使用 for 来创建我们的环形链表
for (int i = 1; i <= nums; i++) {
// 根据编号，创建小孩节点
Boy boy = new Boy(i);
// 如果是第一个小孩
if (i == 1) {
first = boy;
first.setNext(first); // 构成环
curBoy = first; // 让 curBoy 指向第一个小孩
} else {
curBoy.setNext(boy);//
boy.setNext(first);//
curBoy = boy;
}
}
}
// 遍历当前的环形链表
public void showBoy() {
// 判断链表是否为空
if (first == null) {
System.out.println("没有任何小孩~~");
return;
}
Boy curBoy = first;
while (true) {
System.out.printf("小孩的编号 %d \n", curBoy.getNo());
if (curBoy.getNext() == first) {// 说明已经遍历完毕
break;
}
curBoy = curBoy.getNext(); // curBoy 后移
}
}
// 根据用户的输入，计算出小孩出圈的顺序
/**
*
* @param startNo
*
表示从第几个小孩开始数数
* @param countNum
*
表示数几下
* @param nums
*
表示最初有多少小孩在圈中
*/
public void countBoy(int startNo, int countNum, int nums) {
//
先对数据进行校验
if (first == null || startNo < 1 || startNo > nums) {
System.out.println("参数输入有误， 请重新输入");
return;
// 创建要给辅助指针,帮助完成小孩出圈
Boy helper = first;
// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点
while (true) {
if (helper.getNext() == first) { // 说明 helper 指向最后小孩节点
break;
}
helper = helper.getNext();
}
//小孩报数前，先让 first 和 helper 移动 k - 1 次
for(int j = 0; j < startNo - 1; j++) {
first = first.getNext();
helper = helper.getNext();
}
//当小孩报数时，让 first 和 helper 指针同时 的移动 m - 1 次, 然后出圈
//这里是一个循环操作，知道圈中只有一个节点
while(true) {
if(helper == first) { //说明圈中只有一个节点
break;
}
//让 first 和 helper 指针同时 的移动 countNum - 1
for(int j = 0; j < countNum - 1; j++) {
first = first.getNext();
helper = helper.getNext();
}
//这时 first 指向的节点，就是要出圈的小孩节点尚硅谷 Java 数据结构和算法
System.out.printf("小孩%d 出圈\n", first.getNo());
//这时将 first 指向的小孩节点出圈
first = first.getNext();
helper.setNext(first); //
}
System.out.printf("最后留在圈中的小孩编号%d \n", first.getNo());
}
}
// 创建一个 Boy 类，表示一个节点
class Boy {
private int no;// 编号
private Boy next; // 指向下一个节点,默认 null
public Boy(int no) {
this.no = no;
}
public int getNo() {
return no;
}
public void setNo(int no) {
this.no = no;
}
public Boy getNext() {
return next;
}
public void setNext(Boy next) {
this.next = next;
}
}

```

## **5栈**

### **5.1栈的应用**

![img](http://inis.inis1719.cn/202206021239528.png)

### **5.2栈的介绍**

![img](http://inis.inis1719.cn/202206021239529.png)

![img](http://inis.inis1719.cn/202206021239530.png)

- **栈其实就是先进后出的原则,队列是先进先出.另外栈底是不变的,栈顶随着数据的取出而不断变化.**

### **5.3数组实现栈代码实现**

![img](http://inis.inis1719.cn/202206021239531.png)

#### 代码如下

```
package a4z栈.StorgeArray;

public class Storgearray {
    //最大数据
    private int maxsize;
    //模拟数组
    private int[] stack;
    //初始数据
    private int top;
//构造方法赋值栈
    public Storgearray(int size) {
        this.maxsize = size;
        this.stack = new int[this.maxsize];
        this.top = -1;
    }

    //栈满
    public boolean isfull() {
        return top == maxsize - 1;
    }

    //空战
    public boolean isemapy() {
        return top == -1;
    }

    //出栈
    public void pop() {
        if (isemapy()) {
            System.out.println("空战");
            return  ;
        } else {
            int value = stack[top];
            top--;
            System.out.println("当前出栈元素为"+value);
        }
    }
        //入栈
    public  void push(int value){
        top++;
        stack[top]=value;
    }

        //遍历
    public void show(){
        for (int i = top; i >=0 ; i--) {
            System.out.println(stack[i]);
        }
    }
}

```

### **5.4栈实现计算器代码**

![img](http://inis.inis1719.cn/202206021239532.png)

#### 代码如下

```
public class Calculator {
public static void main(String[] args) {
//根据前面老师思路，完成表达式的运算
String expression = "7*2*2-5+1-5+3-4"; // 15//如何处理多位数的问题？
//创建两个栈，数栈，一个符号栈
ArrayStack2 numStack = new ArrayStack2(10);
ArrayStack2 operStack = new ArrayStack2(10);
//定义需要的相关变量
int index = 0;//用于扫描
int num1 = 0;
int num2 = 0;
int oper = 0;
int res = 0;
char ch = ' '; //将每次扫描得到 char 保存到 ch
String keepNum = ""; //用于拼接 多位数
//开始 while 循环的扫描 expression
while(true) {
//依次得到 expression 的每一个字符
ch = expression.substring(index, index+1).charAt(0);
//判断 ch 是什么，然后做相应的处理
if(operStack.isOper(ch)) {//如果运算符
//判断当前的符号栈是否为空
if(!operStack.isEmpty()) {
//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,
就需要从数栈中 pop 出两个数,
//在从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符
号栈
if(operStack.priority(ch) <= operStack.priority(operStack.peek())) {
num1 = numStack.pop();
num2 = numStack.pop();
oper = operStack.pop();
res = numStack.cal(num1, num2, oper);
//把运算的结果如数栈
numStack.push(res);
//然后将当前的操作符入符号栈
operStack.push(ch);
} else {
//如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
operStack.push(ch);
}
}else {
//如果为空直接入符号栈..
operStack.push(ch); // 1 + 3
}
} else { //如果是数，则直接入数栈
//numStack.push(ch - 48); //? "1+3" '1' => 1
//分析思路
//1.
当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
//2.
在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号
才入栈
//3.
因此我们需要定义一个变量 字符串，用于拼接
//处理多位数
keepNum += ch;
//如果 ch 已经是 expression 的最后一位，就直接入栈
if (index == expression.length() - 1) {
numStack.push(Integer.parseInt(keepNum));
}else{
//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
//注意是看后一位，不是 index++尚硅谷 Java 数据结构和算法

if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) {
//如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"
numStack.push(Integer.parseInt(keepNum));
//重要的!!!!!!, keepNum 清空
keepNum = "";
}
}
}
//让 index + 1, 并判断是否扫描到 expression 最后.
index++;
if (index >= expression.length()) {
break;
}
}
//当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行.
while(true) {
//如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】
if(operStack.isEmpty()) {
break;
}
num1 = numStack.pop();
num2 = numStack.pop();
oper = operStack.pop();
res = numStack.cal(num1, num2, oper);
numStack.push(res);//入栈
}
//将数栈的最后数，pop 出，就是结果
int res2 = numStack.pop();
System.out.printf("表达式 %s = %d", expression, res2);
}
}
//先创建一个栈,直接使用前面创建好
//定义一个 ArrayStack2 表示栈, 需要扩展功能
class ArrayStack2 {
private int maxSize; // 栈的大小
private int[] stack; // 数组，数组模拟栈，数据就放在该数组
private int top = -1;// top 表示栈顶，初始化为-1
//构造器
public ArrayStack2(int maxSize) {
this.maxSize = maxSize;
stack = new int[this.maxSize];
}
//增加一个方法，可以返回当前栈顶的值, 但是不是真正的 pop
public int peek() {
return stack[top];
}
//栈满
public boolean isFull() {
return top == maxSize - 1;
}
//栈空
public boolean isEmpty() {
return top == -1;
}
//入栈-push
public void push(int value) {
//先判断栈是否满
if(isFull()) {
System.out.println("栈满");
return;
}
top++;
stack[top] = value;
}
//出栈-pop, 将栈顶的数据返回
public int pop() {
//先判断栈是否空
if(isEmpty()) {
//抛出异常
throw new RuntimeException("栈空，没有数据~");
}
int value = stack[top];
top--;
return value;
}
//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
public void list() {
if(isEmpty()) {
System.out.println("栈空，没有数据~~");
return;
}
//需要从栈顶开始显示数据
for(int i = top; i >= 0 ; i--) {
System.out.printf("stack[%d]=%d\n", i, stack[i]);
}
}
//返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示
//数字越大，则优先级就越高.
public int priority(int oper) {
if(oper == '*' || oper == '/'){
return 1;
} else if (oper == '+' || oper == '-') {
return 0;
} else {
return -1; // 假定目前的表达式只有 +, - , * , /
}
}
//判断是不是一个运算符
public boolean isOper(char val) {
return val == '+' || val == '-' || val == '*' || val == '/';
}
//计算方法
public int cal(int num1, int num2, int oper) {
int res = 0; // res 用于存放计算的结果
switch (oper) {
case '+':
res = num1 + num2;
break;
case '-':
res = num2 - num1;// 注意顺序
break;
case '*':
res = num1 * num2;
break;
case '/':
res = num2 / num1;
break;
default:
break;
}
return res;
}
}

```

### **5.5前缀表达式(从左到右扫描)**

#### 前缀表达式的计算机求值

右至左扫指表达式,遇到数字时,将数字压入堆栈,遇到运算符时,弹出栈顶的两个

数,用运算符对它们做相应的计算(栈顶元素和次顶元素厂,并将结果入栈;重复

述过程直到表达式最左端,最后运算得出的值即为表达式的结果

例如:(3+4)×56对应的前缀表达式就-×+3456】针对前缀表达式求值步骤如下:

1. 从右至左扫描,将6、5、4、3压入堆栈
2. 遇到+运算符,因此弹出3和4(3为栈顶元素,4为次顶元素),计算出3+4的值,得7再将7入栈
3. 接下来是×运算符,因此弹出7和5,计算出7×5=35,将35入栈
4. 最后是-运算符,计算出35-6的值,即29,由此得出最终结果

### **5.6中缀表达式(数学常用的表达式)**

中缀表达式就是常见的运算表达式,如3+4)×5-6

中缀表达式的求值是我们人最熟悉的,但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题,因此,在计算结果时,往往会将中缀表达式转成其它表达式来操作

(一般转成后缀表达式)

### **5.7后缀表达式(从右到左扫描)**

![img](http://inis.inis1719.cn/202206021239533.png)

![img](http://inis.inis1719.cn/202206021239534.png)

总结 

-  前缀表达式  从右到左扫描
-  后缀表达式  从左到右扫描
-  中缀表达式  数学常用的格式

  后缀表达式实现逆波兰计算器

```
package 栈.表达式;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

//逆波兰表达式
public class Stagejisuan {
    public static void main(String[] args) {
        //后缀表达式（逆波兰表达式）
        String suffpersion="3 4 + 5 * 6 - ";
        List<String> list = tolist(suffpersion);
        int i = jisuanarray(list);
        System.out.println(i);

    }
    public static List<String> tolist(String array){
        String[] s = array.split(" ");
        ArrayList<String> list = new ArrayList<>();
        for (String s1 : s) {
            list.add(s1);
        }
        return list;
    }
    public static  int jisuanarray(List<String> array){
        //创建栈
        Stack<String> stack = new Stack<>();
        for (String o : array) {
            //判断是否为数
            if (o.matches("\\d+")) {
                stack.push(o);
            }else {
                int s2 = Integer.parseInt(stack.pop());
                int s1 = Integer.parseInt(stack.pop());
                int res=0;
                if (o.equals("+")){
                             res=s1+s2;
                }else if (o.equals("*")){
                        res =s1*s2;
                }else if (o.equals("-")){
                    res =s1-s2;
                }else if (o.equals("/")){
                    res =s1/s2;
                }
                stack.push(res+"");
            }
        }
        return  Integer.parseInt(stack.pop());
        }
}

```

**5.7中缀表达式转换后缀表达式**

![img](http://inis.inis1719.cn/202206021239535.png)

```
package com.atguigu.stack;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
public class PolandNotation {
public static void main(String[] args) {
//完成将一个中缀表达式转成后缀表达式的功能
//说明
//1. 1+((2+3)×4)-5 => 转成 1 2 3 + 4 × + 5 –尚硅谷 Java 数据结构和算法

//2.
因为直接对 str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》
 中缀的表达式对应的 List
//
即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
//3.
将得到的中缀表达式对应的 List =>
后缀表达式对应的 List
//
即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
=》 ArrayList [1,2,3,+,4,*,+,5,–]
String expression = "1+((2+3)*4)-5";//注意表达式
List<String> infixExpressionList = toInfixExpressionList(expression);
System.out.println("中缀表达式对应的 List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);
System.out.println("后缀表达式对应的 List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–]
System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ?
/*
//先定义给逆波兰表达式
//(30+4)×5-6 => 30 4 + 5 × 6 - => 164
// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
//测试
//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开
//String suffixExpression = "30 4 + 5 * 6 -";
String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
//思路
//1. 先将
"3 4 + 5 × 6 - " => 放到 ArrayList 
//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
List<String> list = getListString(suffixExpression);
System.out.println("rpnList=" + list);
int res = calculate(list);
System.out.println("计算的结果是=" + res);
*/
}
//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]
//方法：将得到的中缀表达式对应的 List => 后缀表达式对应的 List
public static List<String> parseSuffixExpreesionList(List<String> ls) {
//定义两个栈
Stack<String> s1 = new Stack<String>(); // 符号栈
//说明：因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出
//因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
//Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈 s2
List<String> s2 = new ArrayList<String>(); // 储存中间结果的 Lists2
//遍历 ls
for(String item: ls) {
//如果是一个数，加入 s2
if(item.matches("\\d+")) {
s2.add(item);
} else if (item.equals("(")) {
s1.push(item);
} else if (item.equals(")")) {
//如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这
一对括号丢弃
while(!s1.peek().equals("(")) {
s2.add(s1.pop());
}
s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号
} else {
//当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1)
与 s1 中新的栈顶运算符相比较
//问题：我们缺少一个比较优先级高低的方法
while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {
s2.add(s1.pop());
}
//还需要将 item 压入栈
s1.push(item);
}
}
//将 s1 中剩余的运算符依次弹出并加入 s2
while(s1.size() != 0) {
s2.add(s1.pop());
}
return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List
}
//方法：将 中缀表达式转成对应的 List
// s="1+((2+3)×4)-5";
public static List<String> toInfixExpressionList(String s) {
//定义一个 List,存放中缀表达式 对应的内容
List<String> ls = new ArrayList<String>();
int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串
String str; // 对多位数的拼接
char c; // 每遍历到一个字符，就放入到 c
do {
//如果 c 是一个非数字，我需要加入到 ls
if((c=s.charAt(i)) < 48 || (c=s.charAt(i)) > 57) {
ls.add("" + c);
i++; //i 需要后移
} else { //如果是一个数，需要考虑多位数
str = ""; //先将 str 置成"" '0'[48]->'9'[57]
while(i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {
str += c;//拼接
i++;
}
ls.add(str);
}
}while(i < s.length());
return ls;//返回
}
//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中
public static List<String> getListString(String suffixExpression) {
//将 suffixExpression 分割
String[] split = suffixExpression.split(" ");
List<String> list = new ArrayList<String>();
for(String ele: split) {
list.add(ele);
}
return list;
}
//完成对逆波兰表达式的运算
/*
* 1)从左至右扫描，将 3 和 4 压入堆栈；
2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
3)将 5 入栈；
4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
5)将 6 入栈；
6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
*/尚硅谷 Java 数据结构和算法
更多 Java –大数据 –前端
public static int calculate(List<String> ls) {
// 创建给栈, 只需要一个栈即可
Stack<String> stack = new Stack<String>();
// 遍历 ls
for (String item : ls) {
// 这里使用正则表达式来取出数
if (item.matches("\\d+")) { // 匹配的是多位数
// 入栈
stack.push(item);
} else {
// pop 出两个数，并运算， 再入栈
int num2 = Integer.parseInt(stack.pop());
int num1 = Integer.parseInt(stack.pop());
int res = 0;
if (item.equals("+")) {
res = num1 + num2;
} else if (item.equals("-")) {
res = num1 - num2;
} else if (item.equals("*")) {
res = num1 * num2;
} else if (item.equals("/")) {
res = num1 / num2;
} else {
throw new RuntimeException("运算符有误");
}
//把 res

stack.push("" + res);
}
}
//最后留在 stack 中的数据是运算结果
return Integer.parseInt(stack.pop());
}
}
//编写一个类 Operation 可以返回一个运算符 对应的优先级
class Operation {
private static int ADD = 1;
private static int SUB = 1;
private static int MUL = 2;
private static int DIV = 2;
//写一个方法，返回对应的优先级数字
public static int getValue(String operation) {
int result = 0;
switch (operation) {
case "+":
result = ADD;
break;
case "-":
result = SUB;
break;
case "*":
result = MUL;
break;
case "/":
result = DIV;
break;
default:
System.out.println("不存在该运算符");
break;
}
return result;
}
}

```

## **6递归**

### **6.1什么是递归？**

简单的说:递归就是方法自己调用自己每次调用时传入不同的变量递归有助于编程者解决复杂的问题同时可以让代码变得简洁。

![img](http://inis.inis1719.cn/202206021239536.png)

### **6.2递归需要遵守的重要规则**

1. 执行一个方法时,就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的,不会相互影响,比如n变量
3. 如果方法中使用的是引用类型变量比如数组),就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近,否则就是无限递归,死龟了:
5. 当一个方法执行完毕,或者遇到 Return,就会返回,遵守谁调用,就将结果1
6. 返回给谁,同时当方法执行完毕或者返回时,该方法也就执行完毕。

### **6.3递归实现简单迷宫问题**

```
//使用递归回溯来给小球找路
//说明 
//1. map 表示地图
//2. i,j 表示从地图的哪个位置开始出发 (1,1)
//3.
如果小球能到 map[6][5] 位置，则说明通路找到.
//4.
约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走
； 3 表示该点已经
走过，但是走不通
//5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯
/**
*
* @param map 表示地图
* @param i 从哪个位置开始找
* @param j
* @return 如果找到通路，就返回 true, 否则返回 false
*/
public static boolean setWay(int[][] map, int i, int j) {
if(map[6][5] == 2) { // 通路已经找到 ok
return true;
} else {
if(map[i][j] == 0) { //如果当前这个点还没有走过
//按照策略 下->右->上->左 走
map[i][j] = 2; // 假定该点是可以走通.
if(setWay(map, i+1, j)) {//向下走
return true;
} else if (setWay(map, i, j+1)) { //向右走
return true;
} else if (setWay(map, i-1, j)) { //向上
return true;
} else if (setWay(map, i, j-1)){ // 向左走
return true;
} else {
//说明该点是走不通，是死路
map[i][j] = 3;
return false;
}
} else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
return false;
}
}
}
//修改找路的策略，改成 上->右->下->左
public static boolean setWay2(int[][] map, int i, int j) {
if(map[6][5] == 2) { // 通路已经找到 ok
return true;
} else {
if(map[i][j] == 0) { //如果当前这个点还没有走过
//按照策略 上->右->下->左
map[i][j] = 2; // 假定该点是可以走通.
if(setWay2(map, i-1, j)) {//向上走
return true;
} else if (setWay2(map, i, j+1)) { //向右走
return true;
} else if (setWay2(map, i+1, j)) { //向下
return true;
} else if (setWay2(map, i, j-1)){ // 向左走
return true;
} else {
//说明该点是走不通，是死路
map[i][j] = 3;
return false;
}
} else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
return false;
}
}
}
}

```

### **6.4递归解决八皇后问题**

#### **6.4.1八皇后问题算法思路分析**

- 第一个皇后先放第一行第一列
- 第二个皇后放在第二行第一列、然后判断是否OK,如果不OK,继续放在第二列、第三列、依次把所有列都放完,找到一个合适的位置。
- 继续第三个皇后,还是第一列、第二列…直到第8个皇后也能放在一个不冲突的位置,算是找到了一个正确解。
- 当得到一个正确解时,在栈回退到上一个栈时,就会开始回溯,即将第
- 个皇后,放到第一列的所有正确解,全部得到
- 然后回头继续第一个皇后放第二列,后面继续循环执行1,234的步骤
- 【示意图】

说明:理论上应该创建一个二维数组来表示棋盘,但是实际上可以通过算法,用一个一维数组即可解决问题.ar8]={0,4,7,5,2,6,1,3}/对应arr下标表示第几行,即第几个皇后,arr[i]=val,va表示第i+1个皇后,放在第i+1行的第val+1列

```
package com.atguigu.recursion;
public class Queue8 {
//定义一个 max 表示共有多少个皇后
int max = 8;
//定义数组 array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3}
int[] array = new int[max];
static int count = 0;
static int judgeCount = 0;
public static void main(String[] args) {
//测试一把 ， 8 皇后是否正确
Queue8 queue8 = new Queue8();
queue8.check(0);
System.out.printf("一共有%d 解法", count);
System.out.printf("一共判断冲突的次数%d 次", judgeCount); // 1.5w
}
//编写一个方法，放置第 n 个皇后
//特别注意： check 是 每一次递归时，进入到 check 中都有 for(int i = 0; i < max; i++)，因此会有回溯
private void check(int n) {
if(n == max) { //n = 8 , 其实 8 个皇后就既然放好
print();
return;
}

//依次放入皇后，并判断是否冲突
for(int i = 0; i < max; i++) {
//先把当前这个皇后 n , 放到该行的第 1 列
array[n] = i;
//判断当放置第 n 个皇后到 i 列时，是否冲突
if(judge(n)) { // 不冲突
//接着放 n+1 个皇后,即开始递归
check(n+1); //
}
//如果冲突，就继续执行 array[n] = i; 即将第 n 个皇后，放置在本行得 后移的一个位置
}
}
//查看当我们放置第 n 个皇后,
就去检测该皇后是否和前面已经摆放的皇后冲突
/**
*
* @param n 表示第 n 个皇后
* @return
*/
private boolean judge(int n) {
judgeCount++;
for(int i = 0; i < n; i++) {
// 说明
//1. array[i] == array[n]
表示判断 第 n 个皇后是否和前面的 n-1 个皇后在同一列
//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜
线
// n = 1 放置第 2 列
1 n = 1 array[1] = 1
// Math.abs(1-0) == 1
Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1
//3. 判断是否在同一行, 没有必要，n 每次都在递增
if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) {
return false;
}
}
return true;
}
//写一个方法，可以将皇后摆放的位置输出
private void print() {
count++;
for (int i = 0; i < array.length; i++) {
System.out.print(array[i] + " ");
}
System.out.println();
}
}

```

## **7.哈希表**

### **7.1哈希表介绍：**

![img](http://inis.inis1719.cn/202206021239537.png)

### **7.2哈希表代码实现：**

```

package a14哈希表;

public class HashArrays {
    public static void main(String[] args) {
        Hashtablearrays hashtablearrays = new Hashtablearrays(10);
        hashtablearrays.put(new Emp(5,"zzzz"));
        hashtablearrays.put(new Emp(3,"zzzz"));
       hashtablearrays.list();


    }

public static class  Hashtablearrays {
        private  int size;
    private HashLinklist[] array;
    public Hashtablearrays(int maxsize) {
        this.array=   new HashLinklist[maxsize];
        this.size=maxsize;
    }
    public  int Hashfun(int id){
        return  id%size;
    }
    public void put(Emp emp){
        int hashfun = Hashfun(emp.id);
        if (array[hashfun]==null){
            array[hashfun]=new HashLinklist();
            array[hashfun].addorder(emp);

        }else {
            array[hashfun].addorder(emp);
        }
    }
    public void list(){
        for (int i = 0; i < size; i++) {
            if (array[i]==null){
                System.out.println("当前第"+i+"条数据为空");
            }else {
                System.out.println("当前第" + i + "条链表的数据为");
                array[i].list();
            }
        }
    }



}

    //内部类链表
    public static class  HashLinklist{

        private  Emp emp;


        //添加方法(顺序添加)
        public void addorder(Emp addemp) {
            //辅助指针
            Emp temp = emp;
            if (emp == null) {
                emp = addemp;
                return;
            }
            while (true) {
              if(temp.next==null){
                  temp.next=addemp;
                  break;
              }
              temp=temp.next;
            }

        }
        //遍历方法
        public  void list(){
            //辅助指针
            Emp temp = emp;
            while (true){
                if (temp!=null){
                    System.out.println("当前雇员为"+temp);
                    temp=temp.next;
                }else {
                    break;
                }
            }
        }


    }


}

```

## **8.树结构**

### **8.1相对优点**

- 数组  ： 查询快增删慢。
- 链表：   查询慢增删快。
- 树结构： 等于是数组和链表的升级版   增加了查询的速度和增加的速度。

### **8.2树的常用术语**

![img](http://inis.inis1719.cn/202206021239538.png)

### **8.3二叉树（每个夫节点最多只有2个子节点）**

#### **8.3.1二叉树的概念：**

![img](http://inis.inis1719.cn/202206021239539.png)

#### **8.3.2二叉树的分类：** 

1. **满二叉树（最后一层全是叶子节点 且节点数为2的层数次方-1**	   
2. **完全二叉树     （所有的叶子节点都在最后一层或者倒数第二层并且 左边一层的叶子节点在左边，倒数第二层的叶子节点在右边）**

### **8.4完全二叉树**

![img](http://inis.inis1719.cn/202206021239540.png)

### **8.5树的遍历方式**

- - -  前序（先输出根节点在输出左右） 。
    -  中序（左 根右）。
    - 后序（左右根）。

代码如下：

```
package a15树结构;

import java.util.ArrayList;

public class Shudemo {
    public static void main(String[] args) {
     Treedemo array   =   new Treedemo(10, "ZZZ");
        array.setLeft(new Treedemo(13,"www"));
            array.setRight(new Treedemo(12,"qqq"));
        Treelist treelist = new Treelist(array);
        treelist.last();

    }

    public static class  Treelist{
        private   Treedemo root;

        public Treelist(Treedemo root) {
            this.root = root;
        }
        //前序遍历
        public void left(){
            if (this.root!=null){
                this.root.preorder();
            }
        }
        //中序
        public void index(){
            if (this.root!=null){
                this.root.infixorder();
            }
        }
        //后续
        public void last(){
            if (this.root!=null){
                this.root.lastorder();
            }
        }

    }


}

```

```
package a15树结构;

public class Treedemo {
    public   int id;
    public   String name;
    private Treedemo left;
    private Treedemo right;

    public Treedemo() {
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Treedemo getLeft() {
        return left;
    }

    public void setLeft(Treedemo left) {
        this.left = left;
    }

    public Treedemo getRight() {
        return right;
    }

    public void setRight(Treedemo right) {
        this.right = right;
    }

    public Treedemo(int id, String name) {
        this.id = id;
        this.name = name;

    }

    @Override
    public String toString() {
        return "Treedemo{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", left=" + left +
                ", right=" + right +
                '}';
    }
    //前序遍历
    public  void preorder(){
        //根节点
        System.out.println(this);
        //递归实现左右子树
        if (this.left!=null){
            this.left.preorder();
        }
        if (this.right!=null){
            this.right.preorder();
        }
    }
    //中序遍历
    public  void infixorder(){
        if (this.left!=null){
            this.left.preorder();
        }
        //根节点
        System.out.println(this);
        if (this.right!=null){
            this.right.preorder();
        }
    }
    //后续遍历
    public  void lastorder(){

        //递归实现左右子树
        if (this.left!=null){
            this.left.preorder();
        }
        if (this.right!=null){
            this.right.preorder();
        }
        //根节点
        System.out.println(this);

    }
}

```

**8.6二叉树递归删除**

![img](http://inis.inis1719.cn/202206021239541.png)

```

//del
public     void deldemo(int no){
    //当前父节点的左右节点删除、
    if (this.left==null && this.left.id==no){
        this.left=null;
        return;
    }
    if (this.right!=null &&this.right.id==no){
        this.right=null;
        return;
    }
    //递归删除
    if (this.right!=null){
        this.right.deldemo(no);
    }

    if (this.left!=null){
        this.left.deldemo(no);
    }

}

```

```

public void del(int no){
    if (this.root.id==no){
        this.root=null;
        System.out.println("父节点已删除");
    }else {
        this.root.deldemo(no);
    }
}

```



### **8.6顺序二叉树**

顺序二叉树的特点就是对应的索引左子节点等于2xn+1  右节点=2xn+2  ，子节点对应的父节点为（n-1）/2

![img](http://inis.inis1719.cn/202206021239542.png)

![img](http://inis.inis1719.cn/202206021239543.png)

顺序二叉树简单递归代码：

```
package a15树结构.顺序二叉树;

public class Shunxudemo {
    public static void main(String[] args) {
        int[] array={1,2,3,4,2,8,6,4};
         pre(array,0);
    }

    public  static void  pre(int array[],int index){
        if (array.length==0 || array==null){
            System.out.println("当前数组为空");
        }else {
            System.out.println(array[index]);
        }
        if (2*index+1<array.length){
            pre(array,2*index+1);
        }
        if (2*index+2<array.length){
            pre(array,2*index+2);
        }
    }
}

```

### **8.7线索二叉树**

线索二又树基本介绍

- 1)n个结点的二叉链表中含有n+1【公式2nn-1)=n+1】个空指针域。利用二叉链表中的空指针域,存放指向该结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为"线索")
- 这种加上了线索的二叉链表称为线索链表,相应的二叉树称为线索二叉树
- Threaded BinaryTree]。根据线索性质的不同,线索二叉树可分为前序线索
- 二叉树、中序线索二叉树和后序线索二叉树三种
- 3)一个结点的前一个结点,称为前驱结点
- 4)一个结点的后一个结点,称为后继结点

### **8.8赫夫曼树**

#### **8.8.1基本介绍**

1. 给定n个权值作为n个叶子结点,构造一棵二叉树,若该树的带权路径长度(wp)达到最小,称这样的二叉树为最优二叉树,也称为哈夫曼树( HuffmanTre还有的书翻译为霍夫曼树
2. 赫夫曼树是带权路径长度最短的树,权值较大的结点离根较近。

![img](http://inis.inis1719.cn/202206021239544.png)

在这里树的带权路径长度是叶子节点的带权路径长度之和   

其中wpl最小的就是赫夫曼树

![img](http://inis.inis1719.cn/202206021239546.png)

#### **8.8.2思路如下：**

![img](http://inis.inis1719.cn/202206021239547.png)

#### **8.8.3赫夫曼树 代码如下**

在这里他集成了Comparable这个类为的是方便在集合中排序

```
package a1数据结构.a7树结构.赫夫曼树;

public class Hefunode implements Comparable<Hefunode>{
    //权值
    int value;
    public   Hefunode left;
    public  Hefunode right;

    public Hefunode(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }


    @Override
    public String toString() {
        return "Hefunode{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Hefunode hefunode) {
        //从小到大排序
        return this.value-hefunode.value;
    }
}

```

### **8.9二叉排序树（bst）**

二叉排序树其实就是左节点比右节点小

![img](http://inis.inis1719.cn/202206021239548.png)

```
package a1数据结构.a7树结构.二叉顺序树;

import a1数据结构.a7树结构.Treedemo;
import com.sun.source.tree.Tree;

public class SHuxudemo {
    public static void main(String[] args) {
        int[] array = {7, 3, 10, 12, 5, 1, 9, 2};
        erchashu erchashu = new erchashu();
        for (int i = 0; i < array.length; i++) {
            Node node = new Node(array[i]);
            erchashu.add(node);
        }
        erchashu.list();
        System.out.println("==============");
        erchashu.del(3);
        erchashu.list();
    }

    public static class erchashu {
        //root节点
        private Node root;

        public void add(Node node) {
            if (root == null) {
                this.root = node;
            } else {
                root.add(node);
            }
        }

        public void list() {
            root.zhongxu();
        }

        public void del(int id) {
            root.del(id);
        }
    }


    public static class Node {
        public int id;
        public Node left;
        public Node right;

        public Node(int id) {
            this.id = id;
        }

        //删除节点
        public void del(int id) {
            //当前节点
            Node node = serach(id);
            //当前父节点
            Node parent = searchparent(id);
            //第一种情况删除叶子节点
            if (node.left == null && node.right == null) {
                //判断待删除节点是父节点的左节点
                if (parent.left != null && node.id == parent.left.id) {
                    parent.left = null;
                }
                //判断待删除节点是父节点的右节点
                if (parent.right != null && node.id == parent.right.id) {
                    parent.right = null;
                }
            }
            //第二种情况节点下面有一个节点且是左节点
            if (node.left == null && node.right != null) {
                //判断待删除节点是父节点的左节点
                if (node.id == parent.left.id) {
                    parent.left = node.right;
                }
                //判断待删除节点是父节点的右节点
                if (node.id == parent.right.id) {
                    parent.right = node.right;
                }

            }
            //第二种情况节点下面有一个节点且是右节点
            else if (node.right == null && node.left != null) {
                if (node.id == parent.left.id) {
                    parent.left = node.left;
                }
                if (node.id == parent.right.id) {
                    parent.right = node.left;
                }

            }
            //第三种情况删除两个两个节点的节点
            if (node.left != null && node.right != null) {
                int getdelmin = node.getdelmin(node.right);
                node.id = getdelmin;
            }


        }

        public int getdelmin(Node node) {
            while (node.right != null) {
                node = node.left;
            }

            del(node.id);
            return node.id;

        }

        //查找父节点
        public Node searchparent(int id) {

            if (this.left != null && id == this.left.id || this.right != null && id == this.right.id) {
                return this;
            } else {
                if (this.id > id) {
                    return this.left.searchparent(id);
                } else if (this.id > id) {
                    return this.right.searchparent(id);
                } else {
                    return null;
                }
            }
        }

        //查找当前节点
        public Node serach(int id) {
            if (this.id == id) {
                return this;
            } else {
                if (this.id > id) {
                    return this.left.serach(id);
                } else if (this.id < id) {
                    return this.right.serach(id);
                } else {
                    return null;
                }
            }
        }

        //数组添加
        public void add(Node node) {
            if (node != null) {
                if (node.id < this.id) {
                    if (this.left == null) {
                        this.left = node;
                    } else {
                        this.left.add(node);
                    }
                } else {
                    if (this.right == null) {
                        this.right = node;
                    } else {
                        this.right.add(node);
                    }

                }
            } else {
                return;
            }
        }

        //中序遍历
        public void zhongxu() {

            if (this.left != null) {
                this.left.zhongxu();
            }
            System.out.println("节点是" + this.id);
            if (this.right != null) {
                this.right.zhongxu();
            }
        }
    }
}

```

### **8.10平衡二叉树（AVL）**

#### **8.10.1平衡二叉树的介绍**

特点  ： 左右子树的层数相减的绝对值不超过1

![img](http://inis.inis1719.cn/202206021239549.png)

![img](http://inis.inis1719.cn/202206021239550.png)

#### **8.10.2转换为平衡二叉树**

当右子树的层数-左子树的层数>时使用左旋来让树转变为平衡二叉树



##### 左旋

![img](http://inis.inis1719.cn/202206021239551.png)

##### 右旋

![img](http://inis.inis1719.cn/202206021239552.png)

### **8.11多路查找树**

二叉树与b树的区别（其实就是降低树的高度 ）

![img](http://inis.inis1719.cn/202206021239553.png)

#### **8.11.1二叉树的定义**

![img](http://inis.inis1719.cn/202206021239554.png)

### **8.12b树的概念（多叉树）**

![img](http://inis.inis1719.cn/202206021239555.png)

2-3树（简单的b树  其实就是子节点为2的为2节点 ，子节点为3的为3节点  其中这两种节点的子节点要么为空 ，要么是对应的节点个数）

![img](http://inis.inis1719.cn/202206021239556.png)

### **8.13  b+树（数据放在叶子节点）**

![img](http://inis.inis1719.cn/202206021239557.png)

其实b+树的思想其实就是将数组分成好几份，然后得到最开始的值继续分割

上图的思想其实就是

1有序列表先分成3 段9/3 然后取最开始的数

2再将在上述列表两个值的范围之间继续分割

### **8.14b\*树**

![img](http://inis.inis1719.cn/202206021239558.png)

## **9.图**

### **9.1.图的基本概念**

![img](http://inis.inis1719.cn/202206021239559.png)

### **9.2.图的常用概念**

![img](http://inis.inis1719.cn/202206021239560.png)

![img](http://inis.inis1719.cn/202206021239561.png)

### **9.3图的表示方式**

#### **9.3.1邻接矩阵（下图表示的是可以连通的为1 ）**

![img](http://inis.inis1719.cn/202206021239562.png)

#### **9.3.2 邻接表**

![img](http://inis.inis1719.cn/202206021239563.png)

### **9.4图的遍历方式**

![img](http://inis.inis1719.cn/202206021239564.png)

#### **9.4.1深度优先遍历（DFS）**

操作理解： 其实就是先访问第一个节点然后找到领接节点，然后在找到他的领结节点，是一个递归的过程。

![img](http://inis.inis1719.cn/202206021239565.png)

具体操作步骤

![img](http://inis.inis1719.cn/202206021239566.png)

代码如下

```
package a1数据结构.a8图结构;

import javax.swing.*;
import java.util.*;

public class Tustudy {
    public static void main(String[] args) {
        Tustudy tustudy = new Tustudy(5);
        tustudy.addweight("a");
        tustudy.addweight("b");
        tustudy.addweight("c");
        tustudy.addweight("d");
        tustudy.addweight("e");
        tustudy.addz(0, 1, 1);
        tustudy.addz(0, 2, 1);
        tustudy.addz(1, 2, 1);
        tustudy.addz(1, 3, 1);
        tustudy.addz(1, 4, 1);
        tustudy.show();
        System.out.println("深度遍历");
        tustudy.dfs();

    }

    private int[][] edugs;
    private List<String> list;
    public int nums;
    private boolean[] indexw;

    public Tustudy(int n) {
        edugs = new int[n][n];
        list = new ArrayList<String>();
        nums = 0;
        indexw = new boolean[n];
    }


    /**
     * @return 当前节点
     * @Author zhouhelong
     * @Description: 递归处理得到图的深度遍历
     * @Date 13:54 2021/6/16
     * @params indexboolean 查看节点是否被访问过
     **/
    public void dfs(boolean[] indexboolean, int i) {
        System.out.print("节点为" + list.get(i) + "->");
        indexboolean[i] = true;
        //得到当前的领结点下标
        int getnext = getnext(i);
        //判断是否可以联通
        while (getnext != -1) {
            //判断是否访问过
            if (!indexboolean[getnext]) {
                dfs(indexboolean, getnext);
            }
            //被访问过则修改节点
            getnext = gettwonext(i, getnext);
        }


    }

    public void dfs() {
        for (int i = 0; i < length(); i++) {
            if (!indexw[i]) {
                dfs(indexw, i);
            }
        }
    }


    //得到节点的下一个领结节点索引
    public int getnext(int nums) {

        for (int i = 0; i < list.size(); i++) {
            if (edugs[nums][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * @return
     * @Author zhouhelong
     * @Description: 得到下一个领结节点
     * @Date 13:50 2021/6/16
     * @params w1   前一个领结节点
     * @params w2  当前领结节点
     **/
    public int gettwonext(int w1, int w2) {

        for (int i = w2 + 1; i < list.size(); i++) {
            if (edugs[w1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    //添加节点
    public void addweight(String value) {
        list.add(value);
    }

    //添加路径  为0代表不可以走通 为1则反之
    public void addz(int v1, int v2, int weight) {
        edugs[v1][v2] = weight;
        edugs[v2][v1] = weight;
        nums++;
    }

    //得到边的数量
    public int bian() {
        return nums;
    }

    //得到节点的长度
    public int length() {
        return list.size();
    }

    //得到对应数据的下标和值
    public String getindex(int index) {

        return list.get(index);
    }

    //返回指定点的权值

    public int getweight(int v1, int v2) {

        return edugs[v1][v2];
    }


    //展示图
    public void show() {
        for (int[] edug : edugs) {
            System.err.println(Arrays.toString(edug));
        }
    }


}






```

#### **9.4.2广度优先(BFS)**

思想如下：（与深度遍历不同的是

深度遍历： 是将下一个领结点处理。

广度优先： 其实就是将a的可行节点全部得到然后在通过队列的形式处理

）

![img](http://inis.inis1719.cn/202206021239567.png)

步骤如下：

![img](http://inis.inis1719.cn/202206021239568.png)

代码如下：

```
/** 
 * @Author zhouhelong
 * @Description:  广度优先遍历
 * @Date 14:50 2021/6/ 16
 * @params booleans 判断是否访问过
 * @return  n 当前的节点下标
 **/
    public void guangdu(boolean[] booleans, int n) {
        System.out.print("当前节点为" + list.get(n) + "->");
        booleans[n] = true;
        LinkedList query = new LinkedList();
        query.addLast(n);
        while (!query.isEmpty()) {
            query.removeLast();
            //得到下一个领结点
            int i = getnext(n);
            //判断是否被访问过
            if (!booleans[i]) {

                System.out.print("当前节点为" + list.get(i) + "->");
                booleans[i] = true;
                query.addLast(i);

            } else {
                i = gettwonext(n, i);
            }
        }
    }
/** 
 * @Author zhouhelong
 * @Description:   调用广度优先
 * @Date 14:50 2021/6/16
 * @params 
 * @return 
 **/
    public void bfs() {
        for (int i = 0; i < length(); i++) {
            if (!indexw[i]) {
                guangdu(indexw, i);
            }
        }
    }

```

